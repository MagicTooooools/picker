---
title: 北大《区块链技术与应用》——ETH篇
url: https://www.luozhiyun.com/archives/884
source: luozhiyun`s Blog
date: 2025-11-26
fetch_date: 2025-11-27T16:52:30.583128
---

# 北大《区块链技术与应用》——ETH篇

Search for:

Search

[Skip to content](#content)

[luozhiyun`s Blog](https://www.luozhiyun.com/)

我的技术分享

Menu

* [首页](http://www.luozhiyun.com/)
* [Go系列](https://www.luozhiyun.com/archives/category/%E5%90%8E%E7%AB%AF/go)
* [kubernetes源码系列](https://www.luozhiyun.com/archives/tag/%E6%B7%B1%E5%85%A5k8s)
* [关于我](https://www.luozhiyun.com/%E5%85%B3%E4%BA%8E)
* [RSS订阅](https://www.luozhiyun.com/feed)
* [Github](https://github.com/luozhiyun993)

# 北大《区块链技术与应用》——ETH篇

Posted on 2025年11月26日 by [luozhiyun](https://www.luozhiyun.com/archives/author/luoluo1993)

课程地址：<https://www.bilibili.com/video/BV1Vt411X7JF?spm_id_from=333.788.videopod.episodes&vd_source=f482469b15d60c5c26eb4833c6698cd5&p=2>

## ETH发展史

**2013年底：** Vitalik Buterin（V神）发布了以太坊白皮书。他的核心理念是：比特币像一个功能单一的计算器（可编程货币），而世界需要一个更通用的平台，像一台“**世界计算机**”（World Computer）。所以他提出了智能合约的概念，指的是运行在区块链上的、图灵完备的程序。通过使用以太坊虚拟机（EVM）提供的这样的沙盒环境，用于执行智能合约。

2015年7月"Frontier"（前线）**版本上线。这是以太坊的第一个“创世区块”，标志着网络的正式启动，这是时候还仅仅是一个测试版本。**采用的是工作量证明（PoW）的共识机制。

2016年初"Homestead"（家园）版本发布，这是第一个稳定版本，标志着以太坊不再是“测试版”，开始吸引DApp（去中心化应用）构建者。The DAO这个项目诞生了，它是一个去中心化的风险投资基金，通过智能合约管理，它筹集了当时价值约1.5亿美元的ETH。

同时也意味着危机，2016年6月，The DAO 合约遭到“重入攻击”（Re-entrancy Attack），导致约1/3的资金被盗。

所以这个时候社区面临一个哲学困境，是要接受损失，还是进行通过修改协议规则来回滚交易，追回被盗资金。最后社区投票支持硬分叉，追回了资金，成为了今天的主流链，也就是今天的 ETH。另一派坚持不回滚，保留了原始链，就成了另一个币 ETC。

我们接着跳过几年不这么重要的发展期来到**PoS时代**。

为什么要从 PoW 转向 PoS 共识证明呢？我们都知道 PoW 用“工作”来换取记账权，工作量越大，越值得信赖，这就有个问题，需要巨大的电力和硬件成本，这是极度不环保的。

而 PoS 的核心理念是用“抵押”来换取记账权，你抵押的（Stake）越多，越值得信赖。参与者不再需要购买昂贵的矿机，而是需要购买并**质押（锁定）**网络的原生代币，将这些代币作为“**保证金**”或“**押金**”锁在网络中。如果一个验证者试图作恶（例如，提议无效区块、双重签名），网络会**自动销毁**他质押的“保证金，ETH 就是这样降低了约 99.95% 的能耗。

下面说一下ETH是怎么做到的：

2020年12月， **信标链（Beacon Chain）上线**，这是一条**独立运行**的、采用 **PoS** 共识的全新区块链，它唯一的任务就是让验证者质押 ETH 并就 PoS 共识达成一致。此时，ETH 质押是**单向**的（只能存入，不能取出）。

2022年9月15日以太坊团队将原有的 PoW 链（现在称为“**执行层**”）的“引擎”——即 PoW 共识——**拔掉**。然后，将“执行层”**接入**到“信标链”（现在称为“**共识层**”）的 PoS 引擎上。这正式标志着以太坊进入了“PoS 时代”

合并完成后，**2023年4月 "Shapella"（上海 + Capella）发布**启用了质押提款（EIP-4895）。验证者终于可以取出他们质押的 ETH 和奖励，这次升级引入了 `withdrawalsRoot`（提款树根）字段到区块头中。

当然 ETH 的迭代远没有结束，我看社区还在继续讨论新的提案出来。比如 Pectra 、The Verge 与 The Purge 等，感兴趣的可以自行取查阅一下。

## 账户

这里用 BTC 和 ETH 进行对比，首先在 BTC 中，并不存在一个叫做“我的余额”的变量。它是由 UTXO 算出来的，所以假设钱包里有 5 BTC。这 5 BTC 在区块链上可能并不是一个“5”，而是：

* 一笔 2 BTC 的“现金”（UTXO 1）
* 一笔 1.5 BTC 的“现金”（UTXO 2）
* 一笔 1.5 BTC 的“现金”（UTXO 3）

**总余额 = UTXO 1 + UTXO 2 + UTXO 3 = 5 BTC**。

如果想支付 3 BTC，钱包会选择“消耗”掉 UTXO 1 (2 BTC) 和 UTXO 2 (1.5 BTC)，总共 3.5 BTC。然后产生**两个新**的 UTXO：

1. 一个 3 BTC 的 UTXO 发送给您的朋友（支付）。
2. 一个 0.5 BTC 的 UTXO 发送回给您自己（找零）。

旧的 UTXO 1 和 UTXO 2 就被标记为“已花费”，不能再用了。

这种模型的**优点：** 简单、安全、隐私性相对较好（因为找零地址可以是新地址）、易于并行处理交易。 **缺点：** 难以实现复杂的逻辑（例如智能合约），因为它很难跟踪一个“账户”的复杂状态。

ETH 的设计更像是传统的银行系统。每个地址都是一个独立的“账户”。如果地址有 5 ETH，那么在以太坊的“全局账本”上，地址旁边就明确写着 `balance: 5`。

如果要支付 3 ETH，发起一笔交易，声明：“从账户A转 3 ETH 到账户B”，网络验证账户余额（5 ETH）是否足够支付 3 ETH（以及手续费 Gas）。验证通过后，以太坊网络会：

1. 将账户A的 `balance` 减去 3 ETH。
2. 将账户B的 `balance` 加上 3 ETH。

为了防止余额数字被直接篡改，账户里面有 nonce 用来记数，每次交易完毕之后加一，防止重放攻击。

ETH 有两种账户：

外部账户 externally owned account，个人用户钱包，由私钥控制，可以发起交易；

合约账户 smart contract account 由代码（智能合约）控制，没有私钥，它**不能主动**发起交易，只能在被 EOA 或其他合约“调用”（发送消息）时被动执行其代码。

ETH模型的优点：使得智能合约（复杂的应用程序）成为可能。模型更直观，易于开发 DApps。**缺点：** 交易必须按顺序处理（因为有 `nonce` 机制防止重放攻击），这可能导致网络拥堵。

## 数据结构

![image-20251125210438372](https://img.luozhiyun.com/image-20251125210438372.png)

### Merkel Patricia Trie

账户地址到账户状态的映射 ， 账户地址是 160 位。

以太坊 (ETH) 的核心数据结构是 Modified Merkle Patricia Trie, 简称 MPT。我们可以把它拆解成两个关键概念的组合来理解：**Merkle Tree (默克尔树)** 和 **Patricia Trie (帕特里夏·树，或称压缩前缀树)**

**Merkle Tree (默克尔树)**：它是一种哈希树。树底部的每个“叶子”是数据块的哈希值。相邻的哈希值两两组合再哈希，层层向上，最终汇聚成一个**“根哈希” (Root Hash)**，如下图：

这种树有一个特点是只要树中的**任何一个**数据发生（哪怕是 1 bit 的）改变，最终的“根哈希”都会变得完全不同。这使得节点只需比较这一个根哈希，就能快速验证彼此是否拥有完全相同的海量数据。

```
                                                 +-----------------+
                         |   Merkle Root   |  <- 最终的"指纹" (H_ABCD)
                         | (H_AB + H_CD)   |
                         +-----------------+
                                / \
                               /   \
                +---------------+   +---------------+
                |   Hash_AB     |   |   Hash_CD     |  <- 中间节点
                | (H(T1)+H(T2)) |   | (H(T3)+H(T4)) |
                +---------------+   +---------------+
                      / \                 / \
                     /   \               /   \
            +-------+ +-------+     +-------+ +-------+
            | H(T1) | | H(T2) |     | H(T3) | | H(T4) |  <- 叶子节点
            +-------+ +-------+     +-------+ +-------+
                |         |             |         |
            +-------+ +-------+     +-------+ +-------+
            |  T1   | |  T2   |     |  T3   | |  T4   |  <- 原始数据
            +-------+ +-------+     +-------+ +-------+
```

比如我们上图有四个数据块 `T1`, `T2`, `T3`, `T4`，然后计算哈希`H(T1)`, `H(T2)`, `H(T3)`, `H(T4)`构成叶子节点，然后他们的父节点分别由他们拼接起来再哈希获得。如果有人把 `T3` 改成了 `T3*`，那么 `H(T3)` 会变，`Hash_CD` 也会变，最终 `Merkle Root` 会变得**完全不同**。

**Patricia Trie (称压缩前缀树)**

它其实是 Trie 进化而来的，可以高效地**存储和查找键值对 (Key-Value)**，特别是当“键”(Key) 有相同前缀时，它能极大**压缩存储空间**。举个例子，比如我们要存储以下几个键值对（以单词为例）：

* `"romane"`: (值 1)
* `"romanus"`: (值 2)
* `"romulus"`: (值 3)
* `"rubens"`: (值 4)
* `"ruber"`: (值 5)

```
                                            (Root)
                        |
                      "r"
                      / \
                     /   \
                 "om"     "ub"
                 / \         / \
                /   \       /   \
              "an"  "ulus"  "e"   "ens"  (值 4)
              / \     |       |
             /   \  (值 3)    "r"
           "e"   "us"           |
            |     |           (值 5)
          (值 1) (值 2)
```

我们可以看到这个树基本上和 Trie 类似，唯一的区别就是对路径进行了压缩，对比普通前缀树会是 `R -> O -> M -> A -> N -> E`。看，`R->O` 和 `O->M` 都是“单行道”，只有一个子节点。Patricia 的压缩它会把这些单行道合并。`R` 后面有两个分叉 ("o", "u")，所以 "r" 节点保留。但 "r" 之后的 "o" 和 "m" 都是单行道，所以它们被**压缩**成了 `"om"` 节点。同理，"rub" 被压缩成了 `"ub"` 节点。

使用 Patricia Trie结构对 ETH 来说主要有几点好处：

1. ETH 需要跟踪数以亿计的账户，每个账户都有自己的状态（余额、nonce、合约代码等）。Patricia Trie 可以方便的用来将这些数据组织成 key value 对，比如 key 存的是账户地址 (`0x...`)，value存的是该账户的状态信息。
2. 并且以太坊的“键”（如账户地址）非常长（160位或更长）。如果使用标准的前缀树，从根节点到每个叶子节点都会有非常多的层级，而Patricia Trie它会把所有“没有分叉的单行道”路径**压缩合并**成一个节点，从而节省空间。
3. Trie 树的最终形状和根哈希**只取决于它所包含的“键值对”数据**，而与**插入这些数据的顺序无关**。以太坊是一个全球分布式的系统。不同的节点在构建区块时，可能会以不同的顺序处理（本地缓存或插入）状态数据，所以这一点也是至关重要的。
4. 最后就是 Patricia Trie 允许高效的状态更新，当一笔交易发生时（例如，A 转账给 B），通常只有极少数的“值”被改变了（A的余额减少，B的余额增加），种树形结构允许只更新从被修改的叶子节点到根节点的那条路径上的节点。

在 ETH 结构中，有三棵树都是使用的Patricia Trie结构：交易树 (Transaction Trie)、收据树 (Receipts Trie) 、状态树（State Trie），所以我们来看看 ETH 的 Merkel Patricia Trie 是怎么做的。

![image-20251107212146532](https://img.luozhiyun.com/image-20251107212146532.png)

ETH 它把键视为 **16 进制的 nibble（半字节）序列**，用三种节点（Branch / Extension / Leaf）压缩表示键空间，并对每个节点做序列化后取哈希，最后得到整棵树的根哈希，如上图所示。

nibble （半字节）序列简单说就是将输入的 **字节流 (byte stream)** 转换为 **16 进制字符流**。因为一个字节 (Byte) 包含 8-bit，而一个半字节 (Nibble) 包含 4-bit，所以**每一个字节都会被精确地拆分成两个半字节 (nibbles)**。一个 8-bit 的字节，比如 `0x7A`，就会被拆分成了两个 nibbles：`[7, a]`。

下面我们看看三种节点（Branch / Extension / Leaf）：

* **Branch 节点（branch）** — 有 16 个子指针 + 一个可选值槽（用于恰好在此处结束的键）：

  ```
  BranchNode:
  +----------------------------+
  | v0 | v1 | v2 | ... | v15 | value |
  +----------------------------+
  ```

  + v0..v15 共 16 个子指针是因为 Key 被拆分成了半字节 (nibbles) ，用十六进制表示，指向下一层节点（分别对应 nibble 0..15），如果没有对应路径则为 null（或空）；
  + `value` 字段用于当某个键恰好在该节点结束（即键完全耗尽）时保存对应值。
* **Extension 节点（extension）** — 用于把一段**共享前缀**聚合成一条边：

  ```
  ExtensionNode:
  +----------------------+    指向下一级节点
  | path: [nibble数组]   |  --->  子节点
  +----------------------+      (Branch/Leaf/Extension)
  ```

  + `path` 是一段 nibble（十六进制半字节）序列；extension 不包含值，只是压缩中间相同前缀。
* **Leaf 节点（leaf）** — 存储**键的剩余部分**（从分支到末尾）和对应值：

  ```
  LeafNode:
  +---------------------------+
  | path: [剩余 nibble数组]   |
  | value: bytes              |
  +---------------------------+
  ```

  + 当一个键在 trie 中一个分支走到底时，用 leaf 存储剩下的 nibble 和最终值。

比如我们把把三个键插入到空的MPT中：

* Key A：`[a, b, c, d]` -> 值 `V1`
* Key B：`[a, b, c, e]` -> 值 `V2`
* Key C：`[a, b, f]` -> 值 `V3`

```
root = Extension([a,b]) -> Branch
                         /   |   ...
   ...