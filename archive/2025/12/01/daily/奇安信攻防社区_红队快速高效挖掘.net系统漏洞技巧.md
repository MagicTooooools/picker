---
title: 红队快速高效挖掘.net系统漏洞技巧
url: https://forum.butian.net/share/4655
source: 奇安信攻防社区
date: 2025-12-01
fetch_date: 2025-12-02T03:19:16.534217
---

# 红队快速高效挖掘.net系统漏洞技巧

#

[问答](https://forum.butian.net/questions)

*发起*

* [提问](https://forum.butian.net/question/create)
* [文章](https://forum.butian.net/share/create)

[攻防](https://forum.butian.net/community)
[活动](https://forum.butian.net/movable)

Toggle navigation

* [首页 (current)](https://forum.butian.net)
* [问答](https://forum.butian.net/questions)
* [商城](https://forum.butian.net/shop)
* [实战攻防技术](https://forum.butian.net/community)
* [漏洞分析与复现](https://forum.butian.net/articles)
  NEW
* [活动](https://forum.butian.net/movable)
* [摸鱼办](https://forum.butian.net/questions/Play)

搜索

* [登录](https://forum.butian.net/login)
* [注册](https://user.skyeye.qianxin.com/user/register?next=http://forum.butian.net/btlogin)

### 红队快速高效挖掘.net系统漏洞技巧

* [渗透测试](https://forum.butian.net/topic/47)

在红队攻防对抗中，.NET 应用由于采用前端页面（ASPX/ASHX）与托管程序集（DLL）分层架构，这种编译形态具备高度可逆性，使得核心代码逻辑能够通过反编译工具几乎完整还原。利用这一特性，我们可以在获取 DLL 后快速还原源码，通过静态审计与动态调试高效定位 SQL 注入、命令执行、文件上传等高危漏洞。本文将结合漏洞sink点、通用绕过手段与实战案例拆解 .NET 体系下的漏洞挖掘思路，帮助师傅们在红队场景中实现真正的快速高效挖0day。

### 源码获取
\*\*凌风云网盘\*\*
<https://www.lingfengyun.com/>
![image-20251114112536506](https://photoscloud.oss-cn-shanghai.aliyuncs.com/image-20251114112536506.png)
\*\*闲鱼购买\*\*
![image-20251114182742070](https://photoscloud.oss-cn-shanghai.aliyuncs.com/image-20251114182742070.png)
\*\*指纹提取旁站扫描备份文件\*\*
指纹提取 body="xxxx" + 压缩文件目录扫描 （指定文件名www.zip）
![image-20251114182938592](https://photoscloud.oss-cn-shanghai.aliyuncs.com/image-20251114182938592.png)
### 反编译dll+去混淆
反编译 / 静态查看：ILSpy、dnSpy、dotPeek
\*\*dnSpy单个打开并导出到工程\*\*
![image-20251114112235094](https://photoscloud.oss-cn-shanghai.aliyuncs.com/image-20251114112235094.png)
\*\*使用dnSpy批量打开\*\*:
```php
File -&gt; Open -&gt; 选择整个 bin 目录
dnSpy会自动加载所有程序集
```
\*\*使用ILSpy命令行\*\*:
```php
# 安装 ilspycmd
dotnet tool install ilspycmd -g
# 反编译整个目录
ilspycmd -p -o output\_dir .\bin\\*.dll
# 反编译到单个文件
ilspycmd -p -o output.cs .\bin\YourApp.dll
```
\*\*使用脚本批量反编译\*\*:
把下面的代码保存为bat文件，放到bin目录下，该bat脚本会在每个DLL所在目录下创建一个与 DLL 同名的文件夹
（例如 `C:\xxx\lib\test.dll` → `C:\xxx\lib\test\`），并将 `ilspycmd` 的输出写入该文件夹
```java
@echo off
chcp 65001
setlocal enabledelayedexpansion
REM 从当前目录递归查找所有 dll
for /R %%F in (\*.dll) do (
REM %%F = 完整路径（含文件名和扩展名）
set "dll\_path=%%F"
set "dll\_name=%%~nF"
set "dll\_dir=%%~dpF"
set "out\_dir=%%~dpF%%~nF"
echo 正在导出 "%%F" 到 "!out\_dir!\ ..."
if not exist "!out\_dir!\" mkdir "!out\_dir!"
ilspycmd -p -o "!out\_dir!" "%%F"
)
echo 全部完成！
pause
```
\*\*去混淆\*\* : 混淆后的代码可能会出现类似的片段：
```csharp
private string \u0001;
private void \u0002(string \u0003)
{
if (this.\u0001 == \u0003)
}
```
![](https://photoscloud.oss-cn-shanghai.aliyuncs.com/image-20251010154507194.png)
\*\*处理混淆代码\*\*: 使用 de4dot 去混淆，下载程序添加至环境变量
<https://github.com/0xd4d/de4dot>
<https://github.com/ViRb3/de4dot-cex>
```php
de4dot.exe source.dll -o Remove\_obfuscated.dll
de4dot.exe -r D:\input -ru -ro D:\output
```
单个反编译太慢，我们可以使用命令或脚本进行快速批量去混淆
```py
#!/usr/bin/env python3
import os
import subprocess
import shutil
from pathlib import Path
import time
def main():
print("快速de4dot批量反混淆工具")
print("=" \* 40)
try:
result = subprocess.run(["de4dot", "--help"], capture\_output=True, text=True, timeout=5)
if result.returncode != 0:
raise Exception("de4dot命令执行失败")
print("de4dot全局命令检查通过")
except Exception as e:
print(f"de4dot全局命令不可用: {e}")
return
current\_dir = Path(".")
dll\_files = []
for pattern in ["\*.dll", "\*.exe"]:
dll\_files.extend(current\_dir.glob(pattern))
exclude\_patterns = [
"System.", "Microsoft.", "Newtonsoft.", "EntityFramework",
"Oracle.", "MySql.", "NLog.", "Quartz.", "RestSharp",
"StackExchange.", "Thinktecture.", "BouncyCastle"
]
filtered\_files = [f for f in dll\_files if not any(p in f.name for p in exclude\_patterns)]
if not filtered\_files:
print("当前目录没有找到需要处理的DLL文件")
return
print(f"找到 {len(filtered\_files)} 个文件需要处理:")
for f in filtered\_files:
print(f" - {f.name}")
output\_dir = Path("deobfuscated")
output\_dir.mkdir(exist\_ok=True)
print(f"\n开始处理...")
print(f"输出目录: {output\_dir.absolute()}")
success\_count = 0
start\_time = time.time()
for i, dll\_file in enumerate(filtered\_files, 1):
print(f"\n[{i}/{len(filtered\_files)}] 处理: {dll\_file.name}")
try:
output\_subdir = output\_dir / dll\_file.stem
output\_subdir.mkdir(exist\_ok=True)
cmd = ["de4dot", str(dll\_file), "-o", str(output\_subdir / dll\_file.name)]
print(f" 执行: {' '.join(cmd)}")
result = subprocess.run(cmd, capture\_output=True, text=True, timeout=300)
if result.returncode == 0:
print(f" 成功: {dll\_file.name}")
success\_count += 1
else:
print(f" 失败: {dll\_file.name}")
except subprocess.TimeoutExpired:
print(f" 超时: {dll\_file.name}")
except Exception as e:
print(f" 异常: {dll\_file.name} - {e}")
end\_time = time.time()
print(f"\n处理完成! 成功 {success\_count}/{len(filtered\_files)} 个, 耗时 {end\_time - start\_time:.1f} 秒")
print(f"输出目录: {output\_dir.absolute()}")
print("\n批量反混淆完成!")
if \_\_name\_\_ == "\_\_main\_\_":
main()
```
![image-20251022103528196](https://photoscloud.oss-cn-shanghai.aliyuncs.com/image-20251022103528196.png)
去混淆前后对比
![image-20251010154434623](https://photoscloud.oss-cn-shanghai.aliyuncs.com/image-20251010154434623.png)
### ashx和dll映射关系
如 `AjaxUpload.aspx`，逻辑代码在 `AjaxUpload.aspx.cs`，页面会继承 `M\_Main.AjaxUpload` 类，并自动绑定事件
![image-20251024164150928](https://photoscloud.oss-cn-shanghai.aliyuncs.com/image-20251024164150928.png)
这时候我们反编译 `M\_Main.dll`，并找到对应的`AjaxUpload`类，便可以开始愉快的代码审计了
![image-20251024164539667](https://photoscloud.oss-cn-shanghai.aliyuncs.com/image-20251024164539667.png)
![image-20251024172215286](https://photoscloud.oss-cn-shanghai.aliyuncs.com/image-20251024172215286.png)
### 常见漏洞sink点
| 漏洞类型 | 漏洞Sink点 | 审计描述 |
|---|---|---|
| \*\*SQL 注入\*\* | `ExecuteNonQuery()`, `ExecuteReader()`, `ExecuteScalar()`, `SqlDataAdapter.Fill()`, `ExecuteSqlCommand()`, `ExecuteSqlRaw()`, `CreateSQLQuery()`, `connection.Query()` | \*\*检查点\*\*：查找 SQL 语句是否通过字符串拼接或格式化（`+`, `String.Format`, `$""`）将 `Request/Query/Form/Cookie` 等直接插入。 |
| \*\*命令执行（RCE）\*\* | `Process.Start()`, `ProcessStartInfo.FileName`, `ProcessStartInfo.Arguments` | \*\*检查点\*\*：是否把用户输入拼接到命令或传给 shell/PowerShell， `FileName` 与 `Arguments` 是否来自外部 |
| \*\*文件上传 / 任意文件写入\*\* | `SaveAs()`, `WriteAllBytes()`, `WriteAllText()`, `FileStream.Write()` | \*\*检查点\*\*：是否校验扩展名、MIME、内容类型、文件名（路径分隔符）、以及保存目录权限；是否防止覆盖已有文件，上传可执行脚本（`.aspx`/`.ashx`）getshell |
| \*\*反序列化\*\* | `BinaryFormatter.Deserialize()`, `SoapFormatter.Deserialize()`, `JsonConvert.DeserializeObject()`, `LosFormatter.Deserialize()` | \*\*检查点\*\*：反序列化是否对不可信输入（Request、Cookie、ViewState、文件等）执行；是否使用不安全的序列化库（BinaryFormatter、SoapFormatter） |
| \*\*任意文件读取\*\* | `File.ReadAllBytes()`, `File.ReadAllText()`, `Response.WriteFile()`, `Response.TransmitFile()`, `File()` | \*\*检查点\*\*：是否将用户参数直接作为文件路径输出或读取；是否存在未做路径合法化的文件下载接口。 |
| \*\*路径遍历\*\* | `Server.MapPath()`, `Path.Combine()`, `File.Delete()`, `Directory.GetFiles()` | \*\*检查点\*\*：路径拼接是否包含未过滤的用户输入；`Path.Combine` 后是否做规范化校验。 |
| \*\*XXE（XML External Entity）\*\* | `XmlDocument.LoadXml()`, `XmlDocument.Load()`, `XmlReader.Create()`, `DataSet.ReadXml()` | \*\*检查点\*\*：XML 解析是否启用了外部实体解析（DTD）；是否解析来自不受信任来源的 XML。 |
| \*\*SSRF\*\* | `WebClient.DownloadString()`, `HttpClient.GetAsync()`, `WebRequest.Create()`, `HttpClient.PostAsync()` | \*\*检查点\*\*：是否允许用户指定 URL 并由服务器发起请求；是否对目标地址做白名单或内部地址检测。 |
| \*\*远程文件下载\*\* | `WebClient.DownloadFile()、HttpClient.GetStreamAsync()、HttpClient.GetByteArrayAsync()` | \*\*检查点\*\*：是否允许用户提供远程文件 URL（例如通过参数、表单、配置等输入），是否存在任意文件写入风险（保存路径是否可控、是否拼接了用户输入 |
### 未授权访问
#### 检查默认路由暴露
- 默认路由 `{controller}/{action}/{id}` 会将所有 public action 暴露出来
- 查找未授权用户访问敏感控制器/方法，列出所有 Controller 和 public Action，与路由匹配，判断是否有不应暴露的接口
```php
var controllerTypes = typeof(MvcApplication).Assembly.GetTypes()
.Where(t =&gt; t.IsSubclassOf(typeof(Controller)));
foreach (var ctrl in controllerTypes)
{
var actions = ctrl.GetMethods(BindingFlags.Public | BindingFlags.Instance)
.Where(m =&gt; m.ReturnType.IsSubclassOf(typeof(ActionResult)) || m.ReturnType == typeof(ActionResult));
Console.WriteLine($"{ctrl.Name}: {string.Join(", ", actions.Select(a =&gt; a.Name))}");
}
```
#### ASMX公开访问
ASMX是一种用于创建...