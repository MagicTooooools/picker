---
title: 逆向分析CVE-2025-13359：从危险点到攻击入口的完整追踪
url: https://www.anquanke.com/post/id/313581
source: 安全客-有思想的安全新媒体
date: 2025-12-11
fetch_date: 2025-12-12T03:23:07.796736
---

# 逆向分析CVE-2025-13359：从危险点到攻击入口的完整追踪

首页

阅读

* [安全资讯](https://www.anquanke.com/news)
* [安全知识](https://www.anquanke.com/knowledge)
* [安全工具](https://www.anquanke.com/tool)

活动

社区

学院

安全导航

内容精选

* [专栏](/column/index.html)
* [精选专题](https://www.anquanke.com/subject-list)
* [安全KER季刊](https://www.anquanke.com/discovery)
* [360网络安全周报](https://www.anquanke.com/week-list)

# 逆向分析CVE-2025-13359：从危险点到攻击入口的完整追踪

阅读量**19221**

发布时间 : 2025-12-11 14:11:01

**x**

##### 译文声明

本文是翻译文章

译文仅供参考，具体内容表达以及含义原文为准。

## 前言

在一次日常的安全研究中，我偶然发现了 [CVE-2025-13359](https://www.cve.org/CVERecord?id=CVE-2025-13359) 这个漏洞。根据CVE描述，这是一个影响”Tag, Category, and Taxonomy Manager – AI Autotagger with OpenAI” WordPress插件的SQL注入漏洞，影响版本包括3.40.1及之前的所有版本。

作为安全研究员，我决定采用逆向分析的方法：**从漏洞点（危险性点）开始，逆向追踪到攻击入口**。这种分析方法能够更清晰地展示漏洞的完整攻击路径。

---

## 漏洞概述

根据CVE-2025-13359的描述：

* **漏洞类型**: 基于时间的SQL注入（Time-based SQL Injection）
* **影响版本**: ≤ 3.40.1
* **漏洞位置**: `getTermsForAjax`函数
* **权限要求**: Contributor级别及以上（默认启用metabox访问）
* **攻击方式**: 通过`existing_terms_orderby`、`existing_terms_order`等参数注入恶意SQL

---

## 第一步：定位漏洞点（危险性点）

根据CVE描述，漏洞位于`getTermsForAjax`函数中。我首先在代码库中搜索这个函数：

![]()

很快，我在`inc/class.admin.php`文件中找到了这个函数。让我仔细查看它的实现：

```
public static function getTermsForAjax($taxonomy = 'post_tag', $search = '', $order_by = 'name', $order = 'ASC', $limit = '')
{
    global $wpdb;

    if ($order_by === 'random') {
        $order_by = 'RAND()';
    }

    // ... 省略部分代码

    $query = $wpdb->prepare("
        SELECT DISTINCT t.name, t.slug, t.term_id, tt.taxonomy
        FROM {$wpdb->terms} AS t
        INNER JOIN {$wpdb->term_taxonomy} AS tt ON t.term_id = tt.term_id
        WHERE tt.taxonomy = %s
        AND t.name LIKE %s
        ORDER BY $order_by $order $limit  // 漏洞点：直接拼接用户输入
    ", $taxonomy, '%' . $wpdb->esc_like($search) . '%');

    return $wpdb->get_results($query);
}
```

**关键发现**：虽然代码使用了`$wpdb->prepare()`进行参数化查询，但`ORDER BY`和`LIMIT`子句中的`$order_by`、`$order`、`$limit`参数是**直接拼接到SQL字符串中的**，没有进行任何验证或转义！

这就是漏洞的核心：用户可控的参数被直接拼接到SQL查询中，导致SQL注入。

---

## 第二步：逆向追踪调用链

现在我需要找出这些参数是从哪里传递到`getTermsForAjax`函数的。让我搜索所有调用这个函数的地方：

![]()

我发现了几个调用点，其中最引人注目的是`modules/taxopress-ai/classes/TaxoPressAiAjax.php`中的调用。让我逆向追踪这个调用链。

### 逆向追踪路径

#### 调用点1：getTermsForAjax被调用

在`modules/taxopress-ai/classes/TaxoPressAiAjax.php:470`，我找到了调用：

```
$terms = SimpleTags_Admin::getTermsForAjax($existing_tax, $search_text, $existing_terms_orderby, $existing_terms_order, $limit);
```

![]()

这里传递了三个关键参数：

* `$existing_terms_orderby` – 对应漏洞点中的`$order_by`
* `$existing_terms_order` – 对应漏洞点中的`$order`
* `$limit` – 对应漏洞点中的`$limit`

#### 调用点2：参数来源分析

让我查看`get_existing_terms_results`方法（第403行），看看这些参数是从哪里来的：

```
public static function get_existing_terms_results($args) {
    // ...

    if (isset($args['existing_terms_order'])) {
        $existing_terms_order = $args['existing_terms_order'];  // 直接使用，无验证！
    } else {
        $existing_terms_order = 'desc';  // 默认值
    }

    if (isset($args['existing_terms_orderby'])) {
        $existing_terms_orderby = $args['existing_terms_orderby'];  //  直接使用，无验证！
    } else {
        $existing_terms_orderby = 'count';  // 默认值
    }

    // ...

    $terms = SimpleTags_Admin::getTermsForAjax($existing_tax, $search_text, $existing_terms_orderby, $existing_terms_order, $limit);
}
```

**关键发现**：参数从`$args`数组中直接获取，**没有任何白名单验证**！代码应该只允许特定的值（如`name`、`count`、`term_id`、`ASC`、`DESC`等），但实际上任何字符串都可以传递。

#### 调用点3：$args数组的构建

现在我需要找出`$args`数组是在哪里构建的。让我查看调用`get_existing_terms_results`的地方：

在`modules/taxopress-ai/classes/TaxoPressAiAjax.php:190`：

```
$existing_terms_results = self::get_existing_terms_results($args);
```

![]()

让我查看`$args`数组是如何构建的，在`handle_taxopress_ai_preview_feature`方法中（第176-188行）：

```
} elseif ($preview_ai == 'existing_terms') {
    $args['show_counts'] = isset($settings_data['existing_terms_show_post_count']) ? $settings_data['existing_terms_show_post_count'] : 0;
    $args['search_text'] = $search_text;

    if (isset($_POST['existing_terms_order'])) {
        $args['existing_terms_order'] = sanitize_text_field($_POST['existing_terms_order']);
    }
    if (isset($_POST['existing_terms_orderby'])) {
        $args['existing_terms_orderby'] = sanitize_text_field($_POST['existing_terms_orderby']);
    }
    if (isset($_POST['existing_terms_maximum_terms'])) {
        $args['existing_terms_maximum_terms'] = (int)$_POST['existing_terms_maximum_terms'];
    }

    $existing_terms_results = self::get_existing_terms_results($args);
}
```

**关键发现**：代码使用了`sanitize_text_field()`来处理用户输入。这是一个常见的误解！

`sanitize_text_field()`函数的作用是：

* 清理文本内容
* 去除HTML标签
* 去除特殊字符

**但它不能防止SQL注入！** 它不会转义SQL特殊字符（如单引号、分号、注释符`--`等）。这意味着恶意输入如`name) UNION SELECT 1,2,3 --`会原样传递到后续处理中。

#### 调用点4：AJAX处理器入口

现在我需要找出`handle_taxopress_ai_preview_feature`方法是如何被调用的。让我查看AJAX路由注册：

在`modules/taxopress-ai/taxopress-ai.php:42`：

![]()

```
add_action('wp_ajax_taxopress_ai_preview_feature', ['TaxoPressAiAjax', 'handle_taxopress_ai_preview_feature']);
```

这是WordPress的AJAX路由机制。当收到`action=taxopress_ai_preview_feature`的POST请求时，WordPress会自动调用`TaxoPressAiAjax::handle_taxopress_ai_preview_feature()`方法。

让我查看这个方法的完整实现（第56行开始）：

```
public static function handle_taxopress_ai_preview_feature() {
    // Nonce验证
    if (empty($_POST['nonce']) || !wp_verify_nonce(sanitize_key($_POST['nonce']), 'taxopress-ai-ajax-nonce')) {
        // 错误处理
    }

    // 权限检查
    if (!can_manage_taxopress_metabox()) {
        // 错误处理
    }

    // 提取参数
    $preview_ai = !empty($_POST['preview_ai']) ? sanitize_text_field($_POST['preview_ai']) : '';
    $preview_taxonomy = !empty($_POST['preview_taxonomy']) ? sanitize_text_field($_POST['preview_taxonomy']) : '';
    // ...

    if ($preview_ai == 'existing_terms') {
        if (isset($_POST['existing_terms_order'])) {
            $args['existing_terms_order'] = sanitize_text_field($_POST['existing_terms_order']);
        }
        if (isset($_POST['existing_terms_orderby'])) {
            $args['existing_terms_orderby'] = sanitize_text_field($_POST['existing_terms_orderby']);
        }
        // ...
    }
}
```

**安全检查分析**：

* Nonce验证：防止CSRF攻击
* 权限检查：需要`can_manage_taxopress_metabox()`权限（默认Contributor级别）
* 输入验证：只使用了`sanitize_text_field()`，不足以防止SQL注入

#### 调用点5：前端入口点

最后，我需要找出前端是如何发送这个请求的。让我查看JavaScript代码：

在`modules/taxopress-ai/assets/js/taxopress-ai-editor.js:75-87`：

```
var existing_terms_order = preview_wrapper.find('#existing_terms_order :selected').val();
var existing_terms_orderby = preview_wrapper.find('#existing_terms_orderby :selected').val();

var data = {
    action: "taxopress_ai_preview_feature",
    existing_terms_order: existing_terms_order,
    existing_terms_orderby: existing_terms_orderby,
    // ...
};

// 发送AJAX请求
$.ajax({
    url: ajaxurl,
    type: 'POST',
    data: data,
    // ...
});
```

![]()

这些值来自前端的下拉选择框，理论上应该是安全的。但作为安全研究员，我知道前端验证可以被绕过，关键是要看后端如何处理。

---

## 完整攻击路径总结

通过逆向分析，我梳理出了完整的攻击路径：

```
【入口点】前端JavaScript (taxopress-ai-editor.js:75-87)
    ↓ 发送AJAX POST请求
    action=taxopress_ai_preview_feature
    existing_terms_orderby=dd  ← 用户可控
    existing_terms_order=cc    ← 用户可控
    ↓
【路由层】WordPress AJAX路由 (taxopress-ai.php:42)
    ↓ 路由到处理器
    TaxoPressAiAjax::handle_taxopress_ai_preview_feature()
    ↓
【处理层1】AJAX处理器 (TaxoPressAiAjax.php:180-184)
    ↓ 提取参数（仅sanitize_text_field，不足以防止SQL注入）
    $_POST['existing_terms_orderby'] → $args['existing_terms_orderby']
    $_POST['existing_terms_order'] → $args['existing_terms_order']
    ↓
【处理层2】get_existing_terms_results() (TaxoPressAiAjax.php:426-432)
    ↓ 直接使用参数（无验证）
    $args['existing_terms_orderby'] → $existing_terms_orderby
    $args['existing_terms_order'] → $existing_terms_order
    ↓
【处理层3】调用getTermsForAjax() (TaxoPressAiAjax.php:470)
    ↓ 传递未验证的参数
    getTermsForAjax(..., $existing_terms_orderby, $existing_terms_order, $limit)
    ↓
【漏洞点】SQL查询构建 (class.admin.php:1412/1422/1434/1443)
    ↓ 直接拼接到SQL
    ORDER BY $order_by $order $limit
    ↓
【执行点】SQL执行 (class.admin.php:1426)
    ↓ SQL注入成功
    $wpdb->get_results($query)
```

---

## 漏洞利用分析

### 攻击场景

根据CVE描述和我的分析，攻击者需要：

1. 具有Contributor级别权限（默认启用metabox...