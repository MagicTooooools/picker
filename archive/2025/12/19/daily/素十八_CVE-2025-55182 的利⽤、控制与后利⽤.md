---
title: CVE-2025-55182 的利⽤、控制与后利⽤
url: https://su18.org/post/CVE-2025-55182/
source: 素十八
date: 2025-12-19
fetch_date: 2025-12-20T03:18:20.161048
---

# CVE-2025-55182 的利⽤、控制与后利⽤

[![](https://su18.org/images/avatar.png?v=1766117099097)](https://su18.org)

# 素十八

你救赎的人 终将成为你的光

[首页](/)
[归档](/archives)
[标签](/tags)
[Javasec](http://javasec.org)
[Downly](https://www.downly.cn/)

## CVE-2025-55182 的利⽤、控制与后利⽤

2025-12-19

27 min read
[# 漏洞利用](https://su18.org/tag/fQtuCjxPQ/)
[# 绕过](https://su18.org/tag/0HscXmAki/)
[# 内存马](https://su18.org/tag/zqdEkvec9F/)
[# 工具](https://su18.org/tag/mBZEXbIuQ/)
[# 总结](https://su18.org/tag/c16M0jvs3/)
[# 学习笔记](https://su18.org/tag/bbwakgnJvv/)

![](https://su18.org/post-images/CVE-2025-55182.svg)

文笔垃圾，措辞轻浮，内容浅显，操作生疏。不足之处欢迎大师傅们指点和纠正，感激不尽。

# 一、前情提要

很戏剧性的漏洞，从漏洞爆出以来，从第一天的 10.0 引人注目，到假 POC 混淆视听，大家纷纷觉得又是假洞，再到真正的 POC 公布。这个漏洞经历过山车一般的风评，安全圈就是没有虎扑，不然此漏洞的评分将会经历大起大落，从漏洞爆发到现在已经过去两周多，我对此漏洞进行的了深入的研究，深深觉得是一个精妙的漏洞，且影响范围很广。

但是可能因为此漏洞是 NodeJS 并非是 Java 这种安全人员熟知的语言，总是感觉受到的关注度与影响范围并不对等。

但我还是认为，此漏洞获评 10.0 是实至名归。作为全网首发 NodeJS 内存马的实现来说，本篇文章从利用、控制与后利用方向分享我的思路以及实现。

漏洞原理、复现文章等已经有很多优秀的文章已经发布，我也是照着他们抄的，如果你已经对此漏洞有所了解，可以从第三章漏洞利用开始看。

On November 29th, Lachlan Davidson reported a security vulnerability in React that allows unauthenticated remote code execution by exploiting a flaw in how React decodes payloads sent to React Server Function endpoints.

Even if your app does not implement any React Server Function endpoints it may still be vulnerable if your app supports React Server Components.

This vulnerability was disclosed as [CVE-2025-55182](https://www.cve.org/CVERecord?id=CVE-2025-55182) and is rated CVSS 10.0.

The vulnerability is present in versions 19.0, 19.1.0, 19.1.1, and 19.2.0 of:

* [react-server-dom-webpack](https://www.npmjs.com/package/react-server-dom-webpack)
* [react-server-dom-parcel](https://www.npmjs.com/package/react-server-dom-parcel)
* [react-server-dom-turbopack](https://www.npmjs.com/package/react-server-dom-turbopack?activeTab=readme)

React frameworks & bundlers are affected: [next](https://www.npmjs.com/package/next), [react-router](https://www.npmjs.com/package/react-router), [waku](https://www.npmjs.com/package/waku), [@parcel/rsc](https://www.npmjs.com/package/%40parcel/rsc), [@vitejs/plugin-rsc](https://www.npmjs.com/package/%40vitejs/plugin-rsc), and [rwsdk](https://www.npmjs.com/package/rwsdk).

最近更新

These instructions have been updated to include the new vulnerabilities:

* **Denial of Service - High Severity**: [CVE-2025-55184](https://www.cve.org/CVERecord?id=CVE-2025-55184) (CVSS 7.5)
* **Source Code Exposure - Medium Severity**: [CVE-2025-55183](https://www.cve.org/CVERecord?id=CVE-2025-55183) (CVSS 5.3)

They also include the additional case found, patched, and disclosed as [CVE-2025-67779](https://www.cve.org/CVERecord?id=CVE-2025-67779).

在 x 上，有用户称其为 React2Shell，随后还建立了网站：https://react2shell.com/

漏洞点位于 React Server Components 中的 [React Server Functions](https://react.dev/reference/rsc/server-functions)。

[React 服务器端函数](https://react.dev/reference/rsc/server-functions)允许客户端调用服务器上的函数。React 提供了一系列集成点和工具，供框架和打包工具使用，以帮助 React 代码在客户端和服务器端同时运行。React 将客户端请求转换为 HTTP 请求，并将其转发到服务器。在服务器端，React 将 HTTP 请求转换为函数调用，并将所需数据返回给客户端。

因为这个功能实在程序打包时打入进去的，因此尽管开发者没有主动使用 RSF 功能，也会受到漏洞影响。

# 二、漏洞点分析

## 1. 调试环境搭建

按照 P 牛文章逐步操作即可。

创建漏洞版本 next app

```
npx [email protected] nextjs-cve-2025-55182 --yes
```

启动前添加 NODE\_OPTIONS ：`--inspect`

```
# 如果你是Windows系统：set NODE_OPTIONS="--inspect"
export NODE_OPTIONS="--inspect"
npm run dev
```

使用 chrome dev 进行调试：`chrome://inspect/`

关闭排除列表，将 node\_modules 加入 source map。

![](https://su18.org/post-images/1766114520628.png)

## 2. 漏洞分析

### ① day0 fake poc

https://github.com/ejpir/CVE-2025-55182-research/blob/main/exploit-rce-v4.js

这个 github 文件提出的漏洞点位于 requireModule 方法

```
function requireModule(metadata) {
      var moduleExports = __webpack_require__(metadata[0]);
      if (4 === metadata.length && "function" === typeof moduleExports.then)
        if ("fulfilled" === moduleExports.status)
          moduleExports = moduleExports.value;
        else throw moduleExports.reason;
      return "*" === metadata[2]
        ? moduleExports
        : "" === metadata[2]
          ? moduleExports.__esModule
            ? moduleExports.default
            : moduleExports
          : moduleExports[metadata[2]];
    }
```

关键行是 moduleExports， 使用 `[]` 方括号访问属性时，JavaScript 会搜索**整个原型链**

```
moduleExports[metadata[2]]
```

回溯调用链，在 Server 中有两个调用方法，其中一个是 loadServerReference，用于在解析表单提交时的 decodeAction 方法中调用：

```
exports.decodeAction = function (body, serverManifest) {
      var formData = new FormData(),
        action = null;
      body.forEach(function (value, key) {
        key.startsWith("$ACTION_")
          ? key.startsWith("$ACTION_REF_")
            ? ((value = "$ACTION_" + key.slice(12) + ":"),
              (value = decodeBoundActionMetaData(body, serverManifest, value)),
               // 漏洞触发点
              (action = loadServerReference(
                serverManifest,
                value.id,
                value.bound
              )))
            : key.startsWith("$ACTION_ID_") &&
              ((value = key.slice(11)),
              (action = loadServerReference(serverManifest, value, null)))
          : formData.append(key, value);
      });
      return null === action
        ? null
        : action.then(function (fn) {
            return fn.bind(null, formData);
          });
    };
```

请求包

```
------Boundary
Content-Disposition: form-data; name="$ACTION_REF_0"
// 如果字段名以 "$ACTION_" 开头，说明是 action 相关的元数据
// "$ACTION_REF_" 开头，这是"引用型" action，需要从另一个字段读取元数据
// "$ACTION_0:" 元数据前缀

------Boundary
Content-Disposition: form-data; name="$ACTION_0:0"
// 解析 "$ACTION_0:0" 字段中的 JSON
// 得到 id 和 bound

{"id":"xxx","bound":["xxx"]}
------Boundary--
```

关键触发代码：

```
Promise.all([bound, bundlerConfig]).then(function (_ref) {
            _ref = _ref[0];
          // 调用 requireModule
            var fn = requireModule(serverReference);
            return fn.bind.apply(fn, [null].concat(_ref));
          })
```

这部分有点类似 Java 的反射或 PHP 的回调函数，在预加载模块执行完毕后，使用 `fn.bind.apply` 就相当于原始的 id 和 bound 如果如下格式：

```
{"id":"aaaaa#bbbb","bound":["cccc"]}
```

相当于调用

```
aaaaa.bbbbb.bind(null,"cccc")
```

此时如果后续代码中调用了这个解析后的 action，则相当于：

```
aaaaa.bbbbb("cccc")
```

这是个假的漏洞点吗？也不是，能 RCE 吗？好像不能。

前提条件：看 server-reference-manifest 里面都有什么，export 的对象有恶意方法或者export 一个函数，函数里有恶意操作。

就像这个项目里本身手动加入的实现一样，实际找了几个项目，没有能够利用的。

### ② day1 real poc

https://gist.github.com/maple3142/48bc9393f45e068cf8c90ab865c0f5f3

第一天被虚假 POC 带跑偏，分析了一天。第二天老外给出了真 POC，天都塌了。

这何尝不是一种兵法呢。这次吃一堑长一智了，复现这种级别的漏洞得带脑子，不然十分被动。

跟一下真 POC 的触发，以 Next 环境为例：

入口还是 `handleAction` 方法来完成请求的处理，进入 `handleAction` 后，首先会调用 `getServerActionRequestMetadata` 函数提取请求元数据。在`getServerActionRequestMeatdata` 函数中，将尝试提取 `header` 中的 `next-action`，如果存在且不等于 `0`，返回的`isFetchAction` 取值为 `true`，同时如果 `Content-Type` 为 `multipart/form-data` 类型，返回值 `isMultiparAction` 取值为 `true` 。

在后续处理中存在如下判断，如果 `isMultiparAction` 和 `isFetchAction` 均为 `true` ，那么将引入 `busboy` 这个库来做 `http` 解析，这个库常用来处理 `multipart/form-data` 请求，与上面的判断条件一致

`decodeReplyFromBusboy` 方法完成 Flight 反序列化操作，对于 field 类型的请求使用 `resolveField` 方法处理。

```
exports.decodeReplyFromBusboy = function (
      busboyStream,
      webpackMap,
      options
    ) {
      var response = createResponse(
          webpackMap,
          "",
          options ? options.temporaryReferences : void 0
        ),
        pendingFiles = 0,
        queuedFields = [];
      busboyStream.on("field", function (name, value) {
        0 < pendingFiles
          ? queuedFields.push(name, value)
          : resolveField(response, name, value);
      });
```

resolveField

```
function resolveField(response, key, value) {
      response._formData.append(key, value);
      var prefix = response._prefix;
      key.startsWith(prefix) &&
        ((response = response._chunks),
        (key = +key.slice(prefix.length)),
        (prefix = response.get(key)) && resolveModelChunk(prefix, value, key));
    }
```

resolveModelChunk -> initializeModelChunk （JSON 解析）-> reviveModel，这是一个很关键的方法

```
function reviveModel(response, parentObj, parentKey, value, reference) {
 ...