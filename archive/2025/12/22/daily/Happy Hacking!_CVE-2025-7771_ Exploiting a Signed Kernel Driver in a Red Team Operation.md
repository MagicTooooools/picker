---
title: CVE-2025-7771: Exploiting a Signed Kernel Driver in a Red Team Operation
url: https://xavibel.com/2025/12/22/using-vulnerable-drivers-in-red-team-exercises/
source: Happy Hacking!
date: 2025-12-22
fetch_date: 2025-12-23T03:26:58.592537
---

# CVE-2025-7771: Exploiting a Signed Kernel Driver in a Red Team Operation

[Skip to content](#content)

[Happy Hacking!](https://xavibel.com/)

Exploit Dev & Web App Security

![Happy Hacking!](https://xavibel.com/wp-content/uploads/2018/10/cropped-Neo_room-4.jpg)

* [Home](https://xavibel.com/)
* [About me](https://xavibel.com/about-me/)

[← HEVD: Write-What-Where – Windows 10 Pro (SMEP, kCFG, kASLR)](https://xavibel.com/2025/07/01/hevd-write-what-where-windows-10-pro-smep-kcfg-kaslr-protections/)

# CVE-2025-7771: Exploiting a Signed Kernel Driver in a Red Team Operation

Posted on [December 22, 2025](https://xavibel.com/2025/12/22/using-vulnerable-drivers-in-red-team-exercises/ "1:27 pm") by [Xavi](https://xavibel.com/author/xavi/ "View all posts by Xavi")

Hello everyone!

In this blog post, I will share some details about an activity we carried out as part of a Red Team exercise. We identified a vulnerability in a kernel driver and developed an exploit for it. Using this exploit, we disabled several Microsoft protections in the Local Security Authority Subsystem Service (LSASS) process to steal credentials in plain text.

The exploit developed as part of this research targets [CVE-2025-7771](https://www.cve.org/CVERecord?id=CVE-2025-7771).

To the best of our knowledge, no public exploit existed for this vulnerability at the time of writing, and this work represents the first public exploit.

This technique, commonly referred to as **Bring Your Own Vulnerable Driver (BYOVD)**, consists of loading a legitimately signed but vulnerable kernel driver to abuse its flaws for privilege escalation or security control bypass.

Let’s see all the process step by step starting with a brief introduction of why kernel drivers are so useful for attackers.

## Attackers, kernel drivers and Microsoft protections

For an attacker, gaining control of a Windows driver grants kernel-level execution, allowing direct memory manipulation, syscall interception, and raw hardware access. A compromised driver can disable or evade security tools such as EDRs or antivirus, disable or evade Microsoft protections, and serve as a powerful vector to escalate privileges, deploy malware or move laterally.

Windows uses only Ring 0 and Ring 3 for simplicity and cross-platform compatibility, so all hardware drivers run in Ring 0, where they can access privileged instructions and hardware devices.

![](https://xavibel.com/wp-content/uploads/2025/12/1.jpg)

*Privilege rings in processor architecture: Ring 0 (kernel mode) provides the highest privilege*

In this specific attack scenario it was used to disable the Protected Process Light (PPL) Microsoft protection.

To prevent this, Microsoft implemented different protections; two are described below:

* **Driver Signing**
* **Vulnerable Driver Blocklist**

## Driver Signing

Microsoft enforces **[Driver Signing](https://learn.microsoft.com/en-us/windows-hardware/drivers/install/driver-signing)** to maintain the integrity and security of the Windows kernel. Every kernel-mode driver operates with high privileges and can directly interact with hardware and critical system memory. Allowing unsigned or unverified drivers would open the door to malware or unstable code running at the same privilege level as the operating system itself.

By **requiring digital signatures**, Windows ensures that **only verified and untampered drivers can run in kernel mode**. Each signed driver carries cryptographic proof of origin and integrity, ensuring that it hasn’t been altered or injected with malicious payloads.

## Vulnerable Driver Blocklist

The Microsoft Vulnerable **[Driver Blocklist](https://learn.microsoft.com/en-us/windows/security/application-security/application-control/app-control-for-business/design/microsoft-recommended-driver-block-rules)** is a security feature integrated into Windows that prevents the loading of kernel-mode drivers known to carry exploitable vulnerabilities, **even if the drivers are digitally signed**. Microsoft maintains this list in collaboration with hardware vendors and the security research community

Microsoft says in his official webpage that the blocklist is updated typically with each major Windows version (about 1-2 times per year), although Microsoft may release interim updates through Windows Update or as part of security-rollup packages when new threats are identified.

## How to find a signed but unblocked driver?

We considered two possible paths: searching for an unknown vulnerable driver or finding a recently reported vulnerable driver that was not yet included in Microsoft’s blocklist. Due to time constraints, we chose the second path.

Using MITRE, we searched for the latest driver-related CVEs and identified **[CVE-2025-7771](https://www.cve.org/CVERecord?id=CVE-2025-7771)**.

The CVE description contained the following information:
*“ThrottleStop.sys, a legitimate driver, exposes two IOCTL interfaces that allow arbitrary read and write access to physical memory via the MmMapIoSpace function. This insecure implementation can be exploited by a malicious user-mode application to patch the running Windows kernel and invoke arbitrary kernel functions with ring-0 privileges. The vulnerability enables local attackers to execute arbitrary code in kernel context, resulting in privilege escalation and potential follow-on attacks, such as disabling security software or bypassing kernel-level protections. ThrottleStop.sys version 3.0.0.0 and possibly others are affected. Apply updates per vendor instructions.”*

We first installed the **[Throttlestop driver](https://www.techpowerup.com/download/techpowerup-throttlestop/)**, verified its Microsoft signature, and confirmed that it was not present in the Driver Blocklist.

## Testing the driver

After some research, it was observed that the ThrottleStop **software used two different drivers** depending on the version (at least for the versions reviewed). One was **WinRing0**, and the other was **ThrottleStop**.

To interact with them, a service had to be created and the driver .sys file loaded.

```
sc.exe create ThrottleStop type= kernel start= auto binPath= C:\Users\Public\ThrottleStop.sys DisplayName= "ThrottleStop"
net start ThrottleStop
```

```
sc.exe create WinRing0 type= kernel start= auto binPath= C:\Users\Public\WinRing0.sys DisplayName= "WinRing0"
net start WinRing0
```

## Finding the vulnerability

Before starting the reverse-engineering work on the driver, we found an interesting [Kaspersky article](https://securelist.com/av-killer-exploiting-throttlestop-sys/117026/). The article provided useful details, although the IOCTL codes and some other data did not match the driver version we analyzed. Nevertheless, we used it as a valuable reference, as it helped us understand address translation, a topic we will cover later.

We determined that the **vulnerability** relates to **MmMapIoSpace**, a routine that maps a physical address range into nonpaged system space. If a driver allows arbitrary kernel physical addresses to be mapped, an attacker can read from and write to those mapped regions.

## Find the vulnerable IOCTL

Interact with the driver:

```
HANDLE hDrv = NULL;
hDrv = CreateFileA("\\\\.\\ThrottleStop",
    (GENERIC_READ | GENERIC_WRITE),
    0x00,
    NULL,
    OPEN_EXISTING,
    FILE_ATTRIBUTE_NORMAL,
    NULL);

if (hDrv == INVALID_HANDLE_VALUE)
{
    printf("[-] Failed to get a handle on driver!\n");
    return -1;
}
else {
    printf("[+] Handle on  driver received!\n");
}
```

Input Output control code identified:

```
# define IOCTL_MMMAPIOSPACE  0x8000645C
```

## Execute a valid call

To execute a valid call, we needed to understand which structure the driver expected and ensure that it was valid. After some trial and error, we identified the following structure as valid:

```
#pragma pack(push,1)
typedef struct {
    ULONGLONG PhysicalAddress; // +0
    DWORD     NumberOfBytes;   // +8
} PHYS_REQ;                    // 0x0C
#pragma pack(pop)
```

## Confirm the vulnerability

As mentioned earlier, this sof...