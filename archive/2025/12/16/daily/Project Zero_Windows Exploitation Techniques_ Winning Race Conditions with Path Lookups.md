---
title: Windows Exploitation Techniques: Winning Race Conditions with Path Lookups
url: https://projectzero.google/2025/12/windows-exploitation-techniques.html
source: Project Zero
date: 2025-12-16
fetch_date: 2025-12-17T03:22:58.294911
---

# Windows Exploitation Techniques: Winning Race Conditions with Path Lookups

[Project Zero](/)

---

[ ]

* [blog archive](/archive.html)
* [bug reports](https://project-zero.issues.chromium.org/savedsearches/7162405)
* [about](/about-pz.html)
* [Working at PZ](/working-at-project-zero.html)
* [0day: spreadsheet](/0day.html)
* [0day: Root Cause Analyses](https://googleprojectzero.github.io/0days-in-the-wild/rca.html)
* [vulnerability disclosure policy](/vulnerability-disclosure-policy.html)
* [reporting transparency](/reporting-transparency.html)
* search

# Windows Exploitation Techniques: Winning Race Conditions with Path Lookups

[2025-Dec-16](/2025/12/windows-exploitation-techniques.html "Permalink to this post")
James Forshaw

*This post was originally written in 2016 for the Project Zero blog. However, in the end it was published separately in the journal PoC||GTFO [issue #13](https://github.com/angea/pocorgtfo/blob/master/contents/articles/13-03.pdf) as well as in the second volume of the printed version. In honor of our new blog weâre republishing it on this blog and included an updated analysis to see if it still works on a modern Windows 11 system.*

During my Windows research I tend to find quite a few race condition vulnerabilities. A fairly typical exploitable form look something like this:

1. Do some security check
2. Access some resource
3. Perform secure action

If you can change the state of the system between steps 1 and 3 you might be able to bypass a security check or cause other security issues. The big problem is the race window is generally extremely short. In some cases it might be exploitable by running an exploit enough times and hope you hit it at least once. In other cases you might have one shot at success, if you canât guarantee youâll win the race every time it might be effectively unexploitable (however, thatâs not to say you shouldnât report it to the vendor anyway).

Over the years Iâve come up with various techniques to expand the race window, including file Opportunistic Locks and [trapping virtual memory access](https://googleprojectzero.blogspot.com/2021/01/windows-exploitation-tricks-trapping.html). However, those techniques are not always appropriate, so I wanted to find a way of increasing the time window to win the race in cases where the code accesses a resource we control. Specifically, weâre going to attack the lookup process for a named resource. The following is an overview of my thought process to come up with a working solution.

## Investigating Object Manager Lookup Performance

Hidden under the hood of Windows NT is the Object Manager Namespace (OMNS). You wouldnât typically interact with it directly, the Win32 API for the most part hides it away. The NT kernel defines a set of objects, such as Files, Events, Registry Keys, which can all have a name associated with the object. The OMNS provides the means to lookup these named objects. It acts like a file system, so for example you can specify a path to an NT system call such as ***\BaseNamedObjects\MyEvent*** and an event object can be looked up and opened.

There are two special object types which are for use in the OMNS, Object Directories and Symbolic Links. Object Directories act as named containers for other objects, whereas Symbolic Links allow a name to be redirected to another OMNS path. Symbolic Links are used quite a lot, for example the Windows drive letters are really a symbolic link to the real volume device object. When we call an NT system call the kernel must lookup the entire path, following any symbolic links until it reaches the named object, or fails to find a match.

To create a useful exploitation technique, we want to make the process of looking up a resource we control as slow as possible. For example, if we could make it take 1 or 2 seconds, then weâve got a massive window of opportunity to win the race condition. Therefore, I want to find a way of manipulating the Object Manager lookup process in such a way that we achieve this goal.

A note about the testing setup: all tests will open a named event object, which is simulating step 2 in the previous list of exploitable operations. The system used is a new Surface Pro 11th Edition CoPilot+ PC with a Snapdragon X Elite running at 3.40GHz. This system has Windows 11 24H2 installed, however from what I can tell, no AI feature was harmed in the making of these results.

First, letâs just measure the time it takes to do a normal lookup. To try and minimize overhead, weâll write the test in C++ as follows. It creates a named event, then opens the event with a specified number of iterations. Finally itâll return the time in Î¼s that a single iteration took based on the measurement from the [QueryPerformanceCounter](https://learn.microsoft.com/en-us/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) API. Iâve not included the support classes in the listing, thatâll be available in the project Iâll link to later.

```
static double RunTest(const wstring name, int iterations,
        wstring create_name = L"", HANDLE root = nullptr) {
    if (create_name.empty()) {
        create_name = name;
    }
    ScopedHandle event_handle = CreateEvent(create_name, root);
    ObjectAttributes obja(name);
    vector<ScopedHandle> handles;
    Timer timer;
    for (int i = 0; i < iterations; ++i) {
        HANDLE open_handle;
        Check(NtOpenEvent(&open_handle, MAXIMUM_ALLOWED, &obja));
        handles.emplace_back(open_handle);
    }
    return timer.GetTime(iterations);
}
```

For the test Iâll pick a simple unique name, such as ***\BaseNamedObjects\MyEvent**.* With an iteration count of 1000 the results on my test system are probably what weâd expect, the lookup process for a simple named event is approximately 2Î¼s. That includes the system call transition, lookup process and the access check on the event object.

While, in theory, you could win a race with this amount of time, it seems pretty unlikely, even on a multicore processor. So letâs think about a way of improving the lookup time (and when I say âimproveâ I mean making the lookup time slower). We can immediately consider two similar approaches:

1. Make a path which contains one very long name. The lookup process would have to compare the entire name using a string comparison operation to verify itâs accessing the correct object. This should take linear time relative to the length of the string, even if the comparison operation is heavily optimized.
2. Make multiple small named directories and recurse. E.g. **\A\A\A\A\â¦\EventName**. The assumption here is that each lookup takes a fixed amount of time to complete. The operation should again be linear time relative to the depth of recursion of the directories.

At this point weâve not had to look at any actual kernel code, and weâll not start quite yet, so instead more empirical testing seems the way to go. Letâs start with the first approach, making a long string and performing a lookup on it.

How long can the path string be? An object manager path is limited to the maximum string size afforded by the *UNICODE\_STRING* structure.

```
struct UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWSTR  Buffer;
}
```

We can see that the *Length* member is a *USHORT* which is an unsigned 16 bit integer, this limits the maximum length to 216 - 1. This, however, is a byte count so in fact this limits us to 215 - 1 or 32767 wide characters. Weâll need to be able to make the object in a writable directory such as *\BaseNamedObject* which reduces the length slightly, but not enough to make a significant impact. Therefore weâll open the event object through names between 1 character and 32000 characters in length using the following code:

```
std::wstring path;
while (path.size() <= 32000) {
    auto result = RunTest(L"\\BaseNamedObjects\\A" + path, nullptr, 1000);
    printf("%zu,%f\n", path.size(), result);
    path += std::wstring(500, 'A');
}
```

The results are shown below:
![](...