---
title: Use GWP-ASan to detect exploits in production environments
url: https://blog.trailofbits.com/2025/12/16/use-gwp-asan-to-detect-exploits-in-production-environments/
source: The Trail of Bits Blog
date: 2025-12-16
fetch_date: 2025-12-17T03:21:35.889210
---

# Use GWP-ASan to detect exploits in production environments

[The Trail of Bits Blog

Blog](/ "The Trail of Bits Blog")

[![Trail of Bits Logo](/img/tob.png)](https://trailofbits.com "Trail of Bits")

# Use GWP-ASan to detect exploits in production environments

[Dominik Czarnota](/authors/dominik-czarnota/), [Dominik Klemba](/authors/dominik-klemba/)

December 16, 2025

[memory-safety](/categories/memory-safety/), [c/c++](/categories/c/c%2B%2B/), [mitigations](/categories/mitigations/)

Page content

* [How allocation sanitizers work](#how-allocation-sanitizers-work)
* [Where allocation sanitizers are used](#where-allocation-sanitizers-are-used)
* [How to use it in your project](#how-to-use-it-in-your-project)
* [Performance and memory overhead](#performance-and-memory-overhead)
* [Add allocation sanitization to your projects today!](#add-allocation-sanitization-to-your-projects-today)

Memory safety bugs like use-after-free and buffer overflows remain among the most exploited vulnerability classes in production software. While AddressSanitizer (ASan) excels at catching these bugs during development, its [performance overhead (2 to 4 times)](https://developers.redhat.com/blog/2021/05/05/memory-error-checking-in-c-and-c-comparing-sanitizers-and-valgrind) and [security concerns](https://seclists.org/oss-sec/2016/q1/363) make it unsuitable for production. What if you could detect many of the same critical bugs in live systems with virtually no performance impact?

GWP-ASan (GWP-ASan Will Provide Allocation SANity) addresses this gap by using a sampling-based approach. By instrumenting only a fraction of memory allocations, it can detect double-free, use-after-free, and heap-buffer-overflow errors in production at scale while maintaining near-native performance.

In this post, we’ll explain how allocation sanitizers like GWP-ASan work and show how to use one in your projects, using an example based on GWP-ASan from [LLVM’s scudo allocator](https://llvm.org/docs/ScudoHardenedAllocator.html) in C++. We recommend using it to harden security-critical software since it may help you find rare bugs and vulnerabilities used in the wild.

## How allocation sanitizers work

There is more than one allocation sanitizer implementation (e.g., the [Android](https://developer.android.com/ndk/guides/gwp-asan), [TCMalloc](https://google.github.io/tcmalloc/gwp-asan.html), and [Chromium](https://chromium.googlesource.com/chromium/src.git/%2B/HEAD/docs/gwp_asan.md) GWP-ASan implementations, Probabilistic Heap Checker, and [Kernel Electric-Fence [KFENCE]](https://docs.kernel.org/dev-tools/kfence.html)), and they all share core principles derived from [Electric Fence](https://en.wikipedia.org/wiki/Electric_Fence). The key technique is to instrument a randomly chosen fraction of heap allocations and, instead of returning memory from the regular heap, place these allocations in special isolated regions with guard pages to detect memory errors. In other words, GWP-ASan trades detection certainty for performance: instead of catching every bug like ASan does, it catches heap-related bugs (use-after-frees, out-of-bounds-heap accesses, and double-frees) with near-zero overhead.

The allocator surrounds each sampled allocation with two inaccessible guard pages (one directly before and one directly after the allocated memory). If the program attempts to access memory within these guard pages, it triggers detection and reporting of the out-of-bounds access.

However, since operating systems allocate memory in page-sized chunks (typically 4 KB or 16 KB), but applications often request much smaller amounts, there is usually leftover space between the guard pages that won’t trigger detection even though the access should be considered invalid.

To maximize detection of small buffer overruns despite this limitation, GWP-ASan randomly aligns allocations to either the left or right edge of the accessible region, increasing the likelihood that out-of-bounds accesses will hit a guard page rather than landing in the undetected leftover space.

Figure 1 illustrates this concept. The allocated memory is shown in green, the leftover space in yellow, and the inaccessible guard pages in red. While the allocations are aligned to the left or right edge, some memory alignment requirements can create a third scenario:

* **Left alignment:** Catches underflow bugs immediately but detects only larger overflow bugs (such that they access the right guard page)
* **Right alignment:** Detects even single-byte overflows but misses smaller underflow bugs
* **Right alignment with alignment gap:** When allocations have specific alignment requirements (such as structures that must be aligned to certain byte boundaries), GWP-ASan cannot place them right before the second guard page. This creates an unavoidable alignment gap where small buffer overruns may go undetected.

![Figure 1: Alignment of an allocated object within two memory pages protected by two inaccessible guard pages](/2025/12/16/use-gwp-asan-to-detect-exploits-in-production-environments/gwp-asan-image-1_hu_7f6b0553d94dd920.webp)

Figure 1: Alignment of an allocated object within two memory pages protected by two inaccessible guard pages

GWP-ASan also detects use-after-free bugs by making the freed memory pages inaccessible for the instrumented allocations (by [changing their permissions](https://man7.org/linux/man-pages/man2/mprotect.2.html)). Any subsequent access to this memory causes a segmentation fault, allowing GWP-ASan to detect the use-after-free bug.

## Where allocation sanitizers are used

GWP-ASan’s sampling approach makes it viable for production deployment. Rather than instrumenting every allocation like ASan, GWP-ASan typically guards less than 0.1% of allocations, creating negligible performance overhead. This trade-off works at scale—with millions of users, even rare bugs will eventually trigger detection across the user base.

GWP-ASan has been integrated into several major software projects:

* Google developed [GWP-ASan](https://chromium.googlesource.com/chromium/src/%2B/lkgr/docs/gwp_asan.md) for Chromium, which is enabled in Chrome on Windows and macOS [by default](https://chromium.googlesource.com/chromium/src/%2B/lkgr/docs/gwp_asan.md#status).
* It is [available](https://github.com/google/tcmalloc/blob/master/docs/gwp-asan.md) in [TCMalloc](https://github.com/google/tcmalloc/tree/master), Google’s thread-caching memory allocator for C and C++.
* Mozilla reimplemented GWP-ASan as its Probabilistic Heap Checker (PHC) tool, which is [part of Firefox Nightly](https://groups.google.com/g/mozilla.dev.platform/c/AyECjDNsqUE/m/Jd7Jr4cXAgAJ). Mozilla is also working on enabling it on [Firefox’s release channel](https://bugzilla.mozilla.org/show_bug.cgi?id=1801255).
* GWP-ASan is part of Android as well! It’s enabled for some system services and [can be easily enabled for other apps by developers, even without recompilation](https://developer.android.com/ndk/guides/gwp-asan). If you are developing a high profile application, you should consider setting the `android:gwpAsanMode` tag in your app’s manifest to `"always"`. But even without that, since Android 14, all apps use [Recoverable GWP-ASan](https://developer.android.com/ndk/guides/gwp-asan#recoverable) by default, which enables GWP-ASan in ~1% of app launches and reports the detected bugs; however, it does not terminate the app when bugs occur, potentially allowing for a successful exploitation.
* It’s [available in Firebase](https://firebase.blog/posts/2023/03/google-for-games-summit-recap/)’s real-time crash reporting tool Crashlytics.
* It’s available on Apple’s WebKit under the name of [Probabilistic Guard Malloc](https://github.com/WebKit/WebKit/blob/666b3c85e561ad91d3e8873a2a367f3c1dc8cd9b/Source/bmalloc/libpas/Documentation.md#probabilistic-guard-malloc) (please don’t confuse this with Apple’s [Guard Malloc](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/MallocDebug.html), whi...