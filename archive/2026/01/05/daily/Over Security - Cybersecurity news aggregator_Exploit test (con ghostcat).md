---
title: Exploit test (con ghostcat)
url: https://roccosicilia.com/2026/01/05/exploit-test-con-ghostcat/
source: Over Security - Cybersecurity news aggregator
date: 2026-01-05
fetch_date: 2026-01-06T03:31:33.296752
---

# Exploit test (con ghostcat)

# [Rocco Sicilia](https://roccosicilia.com)

Search

* [Home](https://roccosicilia.com)
* [About me](https://roccosicilia.com/about/)
* [Divulgazione](https://roccosicilia.com/progetto-di-divulgazione/)
* [Sostieni il progetto](https://roccosicilia.com/sostieni-il-progetto/)
* [English version](https://medium.com/%40roccosicilia)

[hacking](https://roccosicilia.com/category/hacking/)

## [Exploit test (con ghostcat)](https://roccosicilia.com/2026/01/05/exploit-test-con-ghostcat/)

Published by

Rocco Sicilia

on

[5 gennaio 2026](https://roccosicilia.com/2026/01/05/exploit-test-con-ghostcat/)

[![Exploit test (con ghostcat)](https://roccosicilia.com/wp-content/uploads/2026/01/screenshot-2026-01-05-at-18.15.28.png?w=1013)](https://roccosicilia.com/2026/01/05/exploit-test-con-ghostcat/)

Potrebbe essere un po’ impopolare come opinione, sono comunque convinto che per capirci veramente qualcosa nel mondo del Penetration Testing bisogna veramente immergerti nella melma e dedicare tempo a cose che hanno a che fare con l’informatica molto prima di iniziare a toccare i temi info. security.

Non mi avventuro in una spiegazione teorica di questo concetto, molto più utile mettere in pratica raccontando un micro-task: il testing in lavoratorio di un exploit per una versione vulnerabile di Tomcat.

### Intro

L’obiettivo del test è verificare le condizione che rendono alcune versioni di Apache Tomcat effettivamente *exploitable* tramite l’utilizzo di alcuni payload noti e facilmente reperibili in rete.

Durante una sessione di PenTesting, una volta individuata una vulnerabilità sfruttabile, solitamente si procedere con la verifica tecnica: si tenta di eseguire l’exploit per guadagnare un accesso al sistema target o ottenere nuove informazioni utili. Il fatto che la versione del software (Apache Tomcat in questo caso) corrisponda ad una release che risulta avere delle vulnerabilità non rende automaticamente il sistema attaccabile/manipolabile.

L’effettiva sfruttabilità della falla è legata a diversi fattori:

* l’eventuale applicazione di patch che non hanno alterato la *release version* (ingannando l’analista nel processo di enumeration)
* l’utilizzo di configurazioni non vulnerabili
* la presenza di sistemi di protezione o mitigazione
* fattori esterni non direttamente legati al sistema target

Il contesto condiziona l’utilizzo dell’exploit e non è detto che il PenTester abbia tutte le informazioni necessarie ad una valutazione completa rispetto a quanto viene osservato.

In parole povere il fatto che la scansione approfondita, anche utilizzando tools di mercato che ci danno la certezza della presenza della vulnerabilità, non può mai essere l’elemento determinante finale.

### Analisi della vulnerabilità

Supponiamo di avere un risultato preciso da parte del nostro scan tool e di avere la certezza che sia presente la vulnerabilità (spesso studiata in molti lab) CVE-2020-1938.

![](https://roccosicilia.com/wp-content/uploads/2026/01/image.png?w=1024)
> Nota tecnica: nel mio lab ho predisposto la più classica delle installazioni kali per avere un punto comodo di controllo con il più vasto set di utilities concentrato in una unica macchina. Il risultato della scansione di nmap tramite il set di script disponibili nella repo base restituisce un risultato abbastanza chiaro.

![](https://roccosicilia.com/wp-content/uploads/2026/01/image-1.png?w=1024)

La prima cosa da fare è studiare nel dettaglio la CVE che abbiamo identificato per capire cosa potenzialmente si può fare.

La vulnerabilità è ampiamente documentata ed è relativa ad una specifica componente del servizio: AJP (Apache JServ Protocol) il protocollo binario (non HTTP testuale) usato per far parlare un web server front-end (es: Apache HTTPD o un load balancer)
con il Tomcat che esegue applicazioni Java. Possiamo quindi dire che parlare con AJP ci consente di interagire con il Tomcat che esegue l’applicazione Java e solitamente non è il client ad accedere direttamente a questa componente.

Questa componente è di default attiva e nelle classiche configurazioni che spesso si trovato in giro il servizio (di default in ascolto sulla porta 8009) è attivo sull’interfaccia dell’host assieme al servizio httpd che solitamente, nel caso di Tomcat, è disponibile sulla porta 8080.

![](https://roccosicilia.com/wp-content/uploads/2026/01/image-2.png?w=741)

Default configuration si server.xml in Tomcat 8.0.38 (win)

La vulnerabilità che riguarda questo servizio è così descritta su [NIST](https://nvd.nist.gov/vuln/detail/cve-2020-1938):

*“This vulnerability report identified a mechanism that allowed: – returning arbitrary files from anywhere in the web application – processing any file in the web application as a JSP Further, if the web application allowed file upload and stored those files within the web application (or the attacker was able to control the content of the web application by some other means) then this, along with the ability to process a file as a JSP, made remote code execution possible.”*

In questo post devo muovere qualche critica su come vengono descritte alcune CVE. Sulla prima parte della descrizione nulla da eccepire: il falla consente di accedere in lettura ai file dell’applicazione, cosa che consente all’attaccante di entrare in possesso di informazioni potenzialmente sensibile come dati e configurazioni. È quindi possibile ottenere informazioni che consentano ulteriori azioni verso il sistema.

Poi viene la parte sulla RCE che personalmente la trovo superflua e persino forviante. Cito (mia traduzione): se l’applicazione consente l’upload di file salvati all’interno dell’applicazione […] in combinazione con la possibilità di elaborare file come JSP è possibile eseguire codice da remoto. Ora, ovviamente quanto scritto è corretto ma se trovo una vulnerabilità che mi consente di eseguire l’upload di JSP all’interno dell’applicazione è molto probabile che li possa anche chiamare direttamente via http.

Questo dettaglio mi ha fatto venire voglia di approfondire questa CVE in particolare. Ho fatto un po’ di ricerche per cercare qualche opinione ed esempi: la CVE è stata usata come esempio in diverse “box” ed in tutti gli scenari l’azione era limitata alla raccolta di informazioni in stile CTF a supporto dello scenario di utilizzo della falla per scovare dati usabili in step successivi dell’attacco. Vi suggerisco la lettura di [questo articolo ben scritto](https://infosecwriteups.com/detailed-analysis-of-ghostcat-vulnerability-cve-2020-1938-in-apache-tomcat-servers-and-using-it-736146c986a3). Quello che è certo è che è possibile leggere ed eseguire file tramite questa falla.

### Dettaglio tecnico del bug

Dobbiamo un po’ addentrarci nel funzionamento del software per capirci veramente qualcosa (**a quanto parte lo sport di approfondire è diventato per pochi**) altrimenti rischiamo di fare cose un po’ a caso senza capire perché un exploit funziona o non funziona.

Il bug da cui dipende la vulnerabilità è relativo ad un comportamento di AJP che sostanzialmente accetta degli attributi da parte di chi lo interpella (solitamente Apache). Il problema è che alcuni attributi consentono appunto di accedere a file di configurazione o a contenuti dell’applicazione anche senza meccanismi di sicurezza o autenticazione.

L’exploit deve quindi aprire una sessione direttamente verso AJP (spacciandosi per una richiesta lecita) utilizzando il protocollo di comunicazione come descritto nelle specifiche (qui un po’ di documentazione: <https://tomcat.apache.org/connectors-doc/ajp/ajpv13a.html>) considerando che si tratta appunto di un protocollo binario e non è utilizzabile con semplici messaggi di testo come solitamente siamo abituati con protocolli come HTTP.

Una volta ottenuta la sessione è possibile utilizzare alcuni attributi per chiedere specifiche informazioni. In particolare gli attributi responsabile della falla sono:

* *javax.servlet.include.request\_uri* che dice a Tomcat la URI da cui arriva la richiesta
...