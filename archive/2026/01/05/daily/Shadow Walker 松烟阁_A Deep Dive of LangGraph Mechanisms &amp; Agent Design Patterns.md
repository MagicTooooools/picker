---
title: A Deep Dive of LangGraph Mechanisms &amp; Agent Design Patterns
url: https://www.edony.ink/en/a-deep-dive-of-langgraph-mechanisms-agent-design-patterns/
source: Shadow Walker æ¾çƒŸé˜
date: 2026-01-05
fetch_date: 2026-01-06T03:32:11.114833
---

# A Deep Dive of LangGraph Mechanisms &amp; Agent Design Patterns

[![Shadow Walker æ¾çƒŸé˜](/content/images/2025/11/1573133907wings-cricut-freesvg.org.shadow.walker.for.dark.edit.svg)
![Shadow Walker æ¾çƒŸé˜](https://www.edony.ink/content/images/2024/01/shadow.walker.logo-5.svg)](https://www.edony.ink)

[ğŸ‘¾ å‰ä¸–ä»Šç”Ÿ](https://www.edony.ink/about/)
[ğŸ•°ï¸ æ—¶å…‰ç©¿æ¢­](https://wormhole.edony.ink/)
[ğŸ™ï¸ WalkieTalkie](https://memos.edony.ink/)
[â€¢â€¢â€¢](https://www.edony.ink/...)
[ğŸš‡ Travelling](https://www.travellings.cn/go.html)
[ğŸƒ æˆ‘çš„ä¸“æ ](https://www.edony.ink/private/newsletter-columns/)
[ğŸ¦¶ è¯»è€…è¶³è¿¹](https://www.edony.ink/imprints/)
[ğŸ¦ å¤¨å•ç”µæŠ¥](https://t.me/%2ByoeQpGChKYQzYTU1)
[ğŸš€ åšå®¢è®¡åˆ’](https://trello.com/b/9TxzQwiI/shadow-walker)
[ğŸ£ å–‹å–‹ä¸ä¼‘](https://www.edony.ink/twitter/)
[ğŸ’¯ ä¸ªäººæ¸…å•](https://www.edony.ink/tag/list/)
[ğŸ”˜ æ—§åšå½’æ¡£](https://old.edony.ink/)
[ğŸ“Š æœåŠ¡çŠ¶æ€](https://uptime.edony.ink/status/surveillance)
[ğŸ” ç«™å†…æ£€ç´¢](#/search)

[ğŸ‘¾ å‰ä¸–ä»Šç”Ÿ](https://www.edony.ink/about/)
[ğŸ•°ï¸ æ—¶å…‰ç©¿æ¢­](https://wormhole.edony.ink/)
[ğŸ™ï¸ WalkieTalkie](https://memos.edony.ink/)
[â€¢â€¢â€¢](https://www.edony.ink/...)
[ğŸš‡ Travelling](https://www.travellings.cn/go.html)
[ğŸƒ æˆ‘çš„ä¸“æ ](https://www.edony.ink/private/newsletter-columns/)
[ğŸ¦¶ è¯»è€…è¶³è¿¹](https://www.edony.ink/imprints/)
[ğŸ¦ å¤¨å•ç”µæŠ¥](https://t.me/%2ByoeQpGChKYQzYTU1)
[ğŸš€ åšå®¢è®¡åˆ’](https://trello.com/b/9TxzQwiI/shadow-walker)
[ğŸ£ å–‹å–‹ä¸ä¼‘](https://www.edony.ink/twitter/)
[ğŸ’¯ ä¸ªäººæ¸…å•](https://www.edony.ink/tag/list/)
[ğŸ”˜ æ—§åšå½’æ¡£](https://old.edony.ink/)
[ğŸ“Š æœåŠ¡çŠ¶æ€](https://uptime.edony.ink/status/surveillance)
[ğŸ” ç«™å†…æ£€ç´¢](#/search)
Login
Subscribe

Login
Subscribe

A Deep Dive of LangGraph Mechanisms & Agent Design Patterns

Jan 5, 2026

13 min read

# A Deep Dive of LangGraph Mechanisms & Agent Design Patterns

An unexpected double execution in my CVE agent became the crack that opened LangGraphâ€™s runtime. Under the hood, its â€œsoulâ€ looks closer to Googleâ€™s large-scale graph computing model, Pregelâ€”powered by the Bulk Synchronous Parallel (BSP) philosophy

![A Deep Dive of LangGraph Mechanisms & Agent Design Patterns](/content/images/size/w960/2026/01/0DF6E727-5D0D-442F-87F0-5EF8566BB6DA-1.png)

Photo generated by OpenAI

## Introduction

While building a CVE assessment agent, I ran into an orchestration issue that looked trivial at firstâ€”but turned out to be instructive.

The agent was implemented with LangGraph and (conceptually) structured like this:

graph TD
Start((\_\_start\_\_)) --> GetCVE[get\_cve\_data]
Start --> GetCVSS[get\_cvss\_data]
GetCVE --> GenASD[generate\_asd\_data]
GetCVSS --> GetStmt[get\_cvss\_statement\_data]
GenASD --> Normalize[normalize\_cvss\_data]
GetStmt --> Normalize
Normalize --> GenVector[generate\_cvss\_vector]
GenVector --> End((\_\_end\_\_))

Then the logs started to feelâ€¦ off:

```
2025-12-24 12:07:16|x-sec|INFO|./core/agents/mimora/cvss_vector_agent.py:504|_generate_cvss_vector|å¼€å§‹å®ŒæˆCVEé£é™©è¯„ä¼°å¹¶ç”ŸæˆCVSSå‘é‡
2025-12-24 12:07:16|x-sec|INFO|./core/agents/mimora/cvss_vector_agent.py:401|_normalize_cvss_data|å¼€å§‹å½’ä¸€åŒ–CVSSå‘é‡æ•°æ®
2025-12-24 12:07:26|x-sec|INFO|./core/agents/mimora/cvss_vector_agent.py:527|_generate_cvss_vector|Generated CVSS Vector Response
2025-12-24 12:07:26|x-sec|DEBUG|./core/agents/mimora/cvss_vector_agent.py:528|_generate_cvss_vector|Response content: {
    "cvss_vector": "CVSS:3.1/AV:L/AC:L
2025-12-24 12:07:26|x-sec|INFO|./core/agents/mimora/tools/tool_utils.py:19|wrapper|å¼€å§‹æ‰§è¡Œå·¥å…·: _calculate_cvss_score, å‚æ•°: ('CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H',), {}
2025-12-24 12:07:26|x-sec|INFO|./core/agents/mimora/tools/cvss_tool.py:107|_calculate_cvss_score|å¼€å§‹è®¡ç®—CVSSè¯„åˆ†: version=3.0, vector=CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H...
2025-12-24 12:07:26|x-sec|INFO|./core/agents/mimora/tools/cvss_tool.py:170|_calculate_cvss_score|æˆåŠŸè®¡ç®—CVSSè¯„åˆ†: version=3.1, base_score=7.8, base_severity=High
2025-12-24 12:07:26|x-sec|INFO|./core/agents/mimora/tools/tool_utils.py:22|wrapper|å·¥å…· _calculate_cvss_score æ‰§è¡ŒæˆåŠŸï¼Œè€—æ—¶: 0.00s
2025-12-24 12:07:26|x-sec|INFO|./core/agents/mimora/cvss_vector_agent.py:504|_generate_cvss_vector|å¼€å§‹å®ŒæˆCVEé£é™©è¯„ä¼°å¹¶ç”ŸæˆCVSSå‘é‡
2025-12-24 12:07:26|x-sec|INFO|./core/agents/mimora/cvss_vector_agent.py:568|_generate_cvss_severity|å¼€å§‹ç”ŸæˆCVSSä¸¥é‡æ€§ç­‰çº§
2025-12-24 12:07:35|x-sec|INFO|./core/agents/mimora/cvss_vector_agent.py:527|_generate_cvss_vector|Generated CVSS Vector Response
2025-12-24 12:07:35|x-sec|DEBUG|./core/agents/mimora/cvss_vector_agent.py:528|_generate_cvss_vector|Response content: {
    "cvss_vector": "CVSS:3.1/AV:L/AC:L
2025-12-24 12:07:35|x-sec|INFO|./core/agents/mimora/tools/tool_utils.py:19|wrapper|å¼€å§‹æ‰§è¡Œå·¥å…·: _calculate_cvss_score, å‚æ•°: ('CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H',), {}
2025-12-24 12:07:35|x-sec|INFO|./core/agents/mimora/tools/cvss_tool.py:107|_calculate_cvss_score|å¼€å§‹è®¡ç®—CVSSè¯„åˆ†: version=3.0, vector=CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H...
2025-12-24 12:07:35|x-sec|INFO|./core/agents/mimora/tools/cvss_tool.py:170|_calculate_cvss_score|æˆåŠŸè®¡ç®—CVSSè¯„åˆ†: version=3.1, base_score=7.8, base_severity=High
2025-12-24 12:07:35|x-sec|INFO|./core/agents/mimora/tools/tool_utils.py:22|wrapper|å·¥å…· _calculate_cvss_score æ‰§è¡ŒæˆåŠŸï¼Œè€—æ—¶: 0.00s
2025-12-24 12:07:42|x-sec|INFO|./core/agents/mimora/cvss_vector_agent.py:596|_generate_cvss_severity|Generated CVSS Severity Response
```

The output was unstable. My first instinct was the usual scapegoatâ€”LLM hallucination.
But a graph runtime is supposed to *reduce* this kind of unpredictability, not amplify it.

After tracing the execution path, I found the culprit: `_generate_cvss_vector` was being scheduled twice. That directly contradicted my intended topology.

Iâ€™ll skip the play-by-play debugging here. What matters is what the anomaly triggered: a deeper look into agent orchestrationâ€”and the design patterns that fall out of it.

## Rethinking Agent Orchestration

[![](https://img.spacergif.org/v1/2014x1330/0a/spacer.png)](https://www.edony.ink/content/media/2026/01/1-ezgif-5420e44105c1a33d-1.mp4)

0:00

/0:44

1Ã—

### Where todayâ€™s orchestration starts to crack

As systems evolve from â€œgenerative AIâ€ (single-shot text) into autonomous agents, architecture becomes the real stability leverâ€”more than prompts, more than model choice.

Early paradigms favored *chains*: linear prompt sequences that work well for small, bounded tasks.
But once an agent needs to plan, call tools, reflect, and iterate, a linear DAG (Directed Acyclic Graph) becomes a poor fit.

An agent is not a clean inputâ€“output pipeline. It is a loop of **Perception â†’ Reasoning â†’ Action â†’ Observation**, repeated until terminationâ€”if termination exists at all. That cyclic nature violates the â€œacyclicâ€ assumption. Meanwhile, many systems are drifting toward multi-agent setups: planners, executors, critics, and retrievers collaborating in parallel, all sharing and mutating context.

At that point, you inherit the problems of distributed systems: race conditions, state consistency, cyclic dependencies, and fault tolerance.

So the question becomes: **what orchestration model can represent cycles and parallel collaboration without turning the runtime into a guessing game?**

LangGraphâ€™s bet is to bring the **BSP (Bulk Synchronous Parallel)** modelâ€”battle-tested in HPC and big-data graph computingâ€”into agent orchestration.

### Why graph computing models?

Traditional software models systems as services or objects. An agent system behaves closer to a **state machine traversing a graph**, where *state* is the asset and *transitions* are the work.

1. **Cycles are the default, not the exception**
   ReAct is basically `Think â†’ Act â†’ Observe â†’ Think`. DAGs can express this only indirectly (recursion, outer loops, manual re-entry), which tends to complicate call stacks and context handling. BSP treats cycles naturally: a loop is simply an ongoing sequence of supersteps.
2. **State is the center of gravity**
   In agent systems, context is not â€œdata passing throughâ€â€”it *is* the system. Decisions are functions of the current state. BSP forces explicit state management and versioning, which aligns unusually well with LLM-based workflows.
3. **Parallelism needs a first-class synchronization primitive**
   Patterns like Map-Reduce fan-out or supervisor/work...