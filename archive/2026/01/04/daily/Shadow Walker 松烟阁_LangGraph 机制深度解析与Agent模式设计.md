---
title: LangGraph 机制深度解析与Agent模式设计
url: https://www.edony.ink/deep-insight-of-langgraph-and-bsp-model-in-agent-developing/
source: Shadow Walker 松烟阁
date: 2026-01-04
fetch_date: 2026-01-05T03:55:29.249322
---

# LangGraph 机制深度解析与Agent模式设计

[![Shadow Walker 松烟阁](/content/images/2025/11/1573133907wings-cricut-freesvg.org.shadow.walker.for.dark.edit.svg)
![Shadow Walker 松烟阁](https://www.edony.ink/content/images/2024/01/shadow.walker.logo-5.svg)](https://www.edony.ink)

[👾 前世今生](https://www.edony.ink/about/)
[🕰️ 时光穿梭](https://wormhole.edony.ink/)
[🎙️ WalkieTalkie](https://memos.edony.ink/)
[•••](https://www.edony.ink/...)
[🚇 Travelling](https://www.travellings.cn/go.html)
[🎃 我的专栏](https://www.edony.ink/private/newsletter-columns/)
[🦶 读者足迹](https://www.edony.ink/imprints/)
[🐦 夨坕电报](https://t.me/%2ByoeQpGChKYQzYTU1)
[🚀 博客计划](https://trello.com/b/9TxzQwiI/shadow-walker)
[🐣 喋喋不休](https://www.edony.ink/twitter/)
[💯 个人清单](https://www.edony.ink/tag/list/)
[🔘 旧博归档](https://old.edony.ink/)
[📊 服务状态](https://uptime.edony.ink/status/surveillance)
[🔎 站内检索](#/search)

[👾 前世今生](https://www.edony.ink/about/)
[🕰️ 时光穿梭](https://wormhole.edony.ink/)
[🎙️ WalkieTalkie](https://memos.edony.ink/)
[•••](https://www.edony.ink/...)
[🚇 Travelling](https://www.travellings.cn/go.html)
[🎃 我的专栏](https://www.edony.ink/private/newsletter-columns/)
[🦶 读者足迹](https://www.edony.ink/imprints/)
[🐦 夨坕电报](https://t.me/%2ByoeQpGChKYQzYTU1)
[🚀 博客计划](https://trello.com/b/9TxzQwiI/shadow-walker)
[🐣 喋喋不休](https://www.edony.ink/twitter/)
[💯 个人清单](https://www.edony.ink/tag/list/)
[🔘 旧博归档](https://old.edony.ink/)
[📊 服务状态](https://uptime.edony.ink/status/surveillance)
[🔎 站内检索](#/search)
Login
Subscribe

Login
Subscribe

LangGraph 机制深度解析与Agent模式设计

Jan 4, 2026

32 min read

[AI](/tag/ai/)

# LangGraph 机制深度解析与Agent模式设计

一次异常重复执行让我意外撞开了LangGraph的底层大门，这个Agent框架的灵魂竟是Google大规模图计算模型Pregel。本文跳出简单的Chain思维，深入解析LangGraph基于整体同步并行（BSP）模型的编排哲学。从PregelLoop的源码心跳，到“超级步”如何通过栅栏机制解决多智能体的竞态与幻觉；从Map-Reduce的动态分发到Human-in-the-Loop的优雅中断。这不仅是一次Debug笔记，更是从线性 DAG Agent向图灵完备Agent系统进阶的认知重构，让我重新深入理解Agent的设计模式

![LangGraph 机制深度解析与Agent模式设计](/content/images/size/w960/2026/01/0DF6E727-5D0D-442F-87F0-5EF8566BB6DA.png)

Photo generated by OpenAI

## 引子

我在开发一个CVE相关的Agent的时候，碰到一个很有意思的Agent编排问题，Agent采用LangGraph框架开发的，具体Agent结构如下所示：

![](https://www.edony.ink/content/images/2026/01/image.png)

注意：...为Graph的条件边

Agent运行的结果不稳定，一开始我以为是Agent常见的幻觉问题，但是基于Graph编排就是为了避免幻觉问题，这很奇怪。在排查tracing和调用日志之后，我发现了一个很奇怪的现象：`_generate_cvss_vector` 执行了两次，具体日志如下所示：

```
2025-12-24 12:07:16|x-sec|INFO|./core/agents/mimora/cvss_vector_agent.py:504|_generate_cvss_vector|开始完成CVE风险评估并生成CVSS向量
2025-12-24 12:07:16|x-sec|INFO|./core/agents/mimora/cvss_vector_agent.py:401|_normalize_cvss_data|开始归一化CVSS向量数据
2025-12-24 12:07:26|x-sec|INFO|./core/agents/mimora/cvss_vector_agent.py:527|_generate_cvss_vector|Generated CVSS Vector Response
2025-12-24 12:07:26|x-sec|DEBUG|./core/agents/mimora/cvss_vector_agent.py:528|_generate_cvss_vector|Response content: {
    "cvss_vector": "CVSS:3.1/AV:L/AC:L
2025-12-24 12:07:26|x-sec|INFO|./core/agents/mimora/tools/tool_utils.py:19|wrapper|开始执行工具: _calculate_cvss_score, 参数: ('CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H',), {}
2025-12-24 12:07:26|x-sec|INFO|./core/agents/mimora/tools/cvss_tool.py:107|_calculate_cvss_score|开始计算CVSS评分: version=3.0, vector=CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H...
2025-12-24 12:07:26|x-sec|INFO|./core/agents/mimora/tools/cvss_tool.py:170|_calculate_cvss_score|成功计算CVSS评分: version=3.1, base_score=7.8, base_severity=High
2025-12-24 12:07:26|x-sec|INFO|./core/agents/mimora/tools/tool_utils.py:22|wrapper|工具 _calculate_cvss_score 执行成功，耗时: 0.00s
2025-12-24 12:07:26|x-sec|INFO|./core/agents/mimora/cvss_vector_agent.py:504|_generate_cvss_vector|开始完成CVE风险评估并生成CVSS向量
2025-12-24 12:07:26|x-sec|INFO|./core/agents/mimora/cvss_vector_agent.py:568|_generate_cvss_severity|开始生成CVSS严重性等级
2025-12-24 12:07:35|x-sec|INFO|./core/agents/mimora/cvss_vector_agent.py:527|_generate_cvss_vector|Generated CVSS Vector Response
2025-12-24 12:07:35|x-sec|DEBUG|./core/agents/mimora/cvss_vector_agent.py:528|_generate_cvss_vector|Response content: {
    "cvss_vector": "CVSS:3.1/AV:L/AC:L
2025-12-24 12:07:35|x-sec|INFO|./core/agents/mimora/tools/tool_utils.py:19|wrapper|开始执行工具: _calculate_cvss_score, 参数: ('CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H',), {}
2025-12-24 12:07:35|x-sec|INFO|./core/agents/mimora/tools/cvss_tool.py:107|_calculate_cvss_score|开始计算CVSS评分: version=3.0, vector=CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H...
2025-12-24 12:07:35|x-sec|INFO|./core/agents/mimora/tools/cvss_tool.py:170|_calculate_cvss_score|成功计算CVSS评分: version=3.1, base_score=7.8, base_severity=High
2025-12-24 12:07:35|x-sec|INFO|./core/agents/mimora/tools/tool_utils.py:22|wrapper|工具 _calculate_cvss_score 执行成功，耗时: 0.00s
2025-12-24 12:07:42|x-sec|INFO|./core/agents/mimora/cvss_vector_agent.py:596|_generate_cvss_severity|Generated CVSS Severity Response
```

这与Agent的Graph设计编排动作并不符合，定位过程这里不细说，但是这引起了我对Agent设计模式的好奇，这篇文章我就来探索一下这个问题。

## Agent编排问题思考

[![](https://img.spacergif.org/v1/2014x1330/0a/spacer.png)](https://www.edony.ink/content/media/2026/01/1-ezgif-5420e44105c1a33d-1.mp4)

0:00

/0:44

1×

### Agent编排有什么问题

在生成式人工智能（Generative AI）从单纯的文本生成向自主智能体（Autonomous Agents）演进的历史进程中，编排框架的架构设计成为了决定系统稳定性、可扩展性和复杂度的核心变量。早期的开发范式主要围绕“链式”（Chain）结构展开，这种线性的 Prompt 序列在处理单一、短程任务时表现出色。然而，随着需求转向能够自主决策、使用工具、自我反思并进行长期规划的“智能体”，线性有向无环图（DAG）的局限性暴露无遗。

Agent系统的本质不再是简单的输入-输出管道，而是一个包含了感知（Perception）、决策（Reasoning）、行动（Action）和观察（Observation）的无限循环。这种循环性（Cycles）打破了传统的 DAG 假设。更为关键的是，Agent系统往往不再是单打独斗，而是演变为多智体系统（Multi-Agent Systems），其中多个专注于不同领域的智能体（如规划者、执行者、审查者）需要并行工作并共享上下文 。

随着Agent系统的演进，在编排Agent系统的时候会碰到很多问题，例如需要解决多智体协作中的竞态条件（Race Conditions）、状态一致性（State Consistency）、循环推理（Cyclic Reasoning）以及容错恢复（Fault Tolerance）等，此时开发者不禁会思考能否有一个图灵完备的编排模型来解决这个问题呢？

面对这样的Agent编排的问题，LangGraph将已经在高性能计算（HPC）和大数据处理领域验证过的 BSP 模型引入到了 AI Agent 的编排中。

### 为什么是图计算模型

传统的软件工程倾向于将系统建模为服务（Services）或对象（Objects），而 AI Agent 的行为模式更接近于**状态机（State Machine）** 在图上的随机游走。

* 非线性与循环： Agent 的核心特征是循环（Looping）。例如，ReAct 模式（Reasoning + Acting）本质上是一个 Think -> Act -> Observe -> Think 的闭环。DAG（有向无环图）无法原生表达这种循环，通常需要通过递归调用或外部循环来实现，这会导致调用栈溢出或上下文管理混乱。BSP 模型天生支持循环——循环仅仅是无限的超步序列而已。
* 状态的中心地位： 在 Agent 系统中，Context（上下文/状态）是核心资产。所有的决策都基于当前的 State。BSP 模型强制要求显式的状态管理和版本控制，这与 Agent 对上下文依赖的需求不谋而合。
* 并发与协作： 现代 Agent 系统往往是多角色的（Map-Reduce pattern, Supervisor pattern）。多个 Agent 需要并行工作并汇聚结果。BSP 的栅栏机制天然解决了并行任务的同步与汇聚问题，无需开发者手动编写复杂的 asyncio.gather 或锁机制 。

## Google Pregel&BSP模型

### Google Pregel框架

Pregel 的核心可以用三个图来概括：

* 怎么算： “顶点状态机” —— 决定节点是工作还是休息。
* 怎么跑： “BSP模型” —— 决定整个集群如何同步。
* 怎么传： “最大值传播示例” —— 演示一个具体算法在图上的流动。

![](https://www.edony.ink/content/images/2026/01/image-1.png)

如上图所示，这是 Pregel "Think Like a Vertex"（像顶点一样思考） 的核心。 每个顶点只有两种状态：活跃 (Active) 和 不活跃 (Inactive/Halted)。

* Active (活跃): 顶点正在计算。它可以处理收到的消息，更新自己的值，并向邻居发送新消息。
* Inactive (不活跃): 顶点“睡着了”。如果它觉得自己没活干了（比如计算结果收敛了），就投票休眠（Vote to Halt）。
* 被唤醒: 哪怕顶点睡着了，只要它收到了新消息，系统会立刻把它强制唤醒（切换回 Active），让它处理消息。

![](https://www.edony.ink/content/images/2026/01/image-2.png)

如上图所示，这是 Pregel 在分布式集群上的宏观运行方式。 计算被切分成一个个 Superstep（超步），所有机器必须“齐步走”。

* 计算 (Compute): 所有顶点并行处理自己的逻辑（读上一轮消息 -> 算 -> 发下一轮消息）。
* 通信 (Messages): 这一轮发出的消息，会在网络中飞一会儿。
* 路障 (Barrier): 这是关键。 所有顶点必须都跑完 Superstep S，且消息都传到了，才能一起进入 Superstep S+1。不允许有的跑得快，有的跑得慢。

这种“走一步、停一步、等一等”的模式，解决了分布式系统中极其复杂的死锁和竞态条件问题。

![](https://www.edony.ink/content/images/2026/01/image-3.png)

如上图所示，假设我们要在一个图里找到最大的数字（在这个例子中是 6）并传给所有人。

* Superstep 0: 大家都有初始值。节点 1 拿着最大值 6。
* 消息传递: 节点 1 发现自己值是 6，告诉邻居节点 2：“嘿，我有 6”。
* Superstep 1: 节点 2 收到了“6”，对比自己原来的“3”，发现 6 更大，于是更新自己为 6，并在下一轮继续传播。
* 结果: 就像病毒扩散一样，最大值会在几次 Superstep 后覆盖全图。

### BSP模型

Bulk Synchronous Parallel (BSP) 模型是一种整体同步并行计算模型，由计算机科学家 Leslie Valiant 提出。它将并行计算划分为一系列 **超级步（Superstep）** 顺序执行。在每个超级步内，所有处理单元都执行以下三个阶段：

1. 本地计算阶段：每个处理单元（例如处理器或节点）使用当前可用的数据执行计算。各处理单元彼此独立、并行地进行局部运算。
2. 消息传递阶段：处理单元将本超级步产生的输出发送为消息给其他处理单元。这些消息在本超级步内不会被目标立即处理，而是累积起来供下一个超级步使用。
3. 全局同步屏障阶段：所有处理单元在此同步点等待，直到每个单元都完成了本超级步的前两阶段。同步屏障确保没有单元抢先进入下一超级步。

以上三个阶段严格串行发生：只有当所有处理单元完成本地计算后，才进行统一的通信，然后才能执行同步。同步屏障标志着一个超步的结束和下一个超步的开始。整个 BSP 程序由若干连续的超步构成，重复“计算->通信->同步”的流程，直到满足终止条件。由于通信中的消息仅在同步后才可见，这保证了每个超步各处理单元看到的是上一超步结束时的全局一致状态。BSP 模型具有易于编程、性能可预测且不易出现死锁等特点。从程序员视角来看，BSP 提供了一种简洁的并行语义：把并发逻辑写成在同步栅栏之间交替进行的计算和通信步骤，从而降低了思维复杂度。

[![]...